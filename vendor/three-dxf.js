!function(t,n){"object"==typeof exports&&"object"==typeof module?module.exports=n(require("THREE")):"function"==typeof define&&define.amd?define(["THREE"],n):"object"==typeof exports?exports.ThreeDxf=n(require("THREE")):t.ThreeDxf=n(t.THREE)}("undefined"!=typeof self?self:this,function(__WEBPACK_EXTERNAL_MODULE__0__){return function(t){var n={};function e(g){if(n[g])return n[g].exports;var I=n[g]={i:g,l:!1,exports:{}};return t[g].call(I.exports,I,I.exports,e),I.l=!0,I.exports}return e.m=t,e.c=n,e.d=function(t,n,g){e.o(t,n)||Object.defineProperty(t,n,{enumerable:!0,get:g})},e.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},e.t=function(t,n){if(1&n&&(t=e(t)),8&n)return t;if(4&n&&"object"==typeof t&&t&&t.__esModule)return t;var g=Object.create(null);if(e.r(g),Object.defineProperty(g,"default",{enumerable:!0,value:t}),2&n&&"string"!=typeof t)for(var I in t)e.d(g,I,function(n){return t[n]}.bind(null,I));return g},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},e.p="",e(e.s=1)}([function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE__0__;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9UaHJlZUR4Zi9leHRlcm5hbCBcIlRIUkVFXCI/ZmMwMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18wX187Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: external "THREE"\nvar external_THREE_ = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./src/OrbitControls.js\n/**\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author erich666 / http://erichaines.com\n */\n/*global THREE, console */\n\n// This set of controls performs orbiting, dollying (zooming), and panning. It maintains\n// the "up" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\n// supported.\n//\n//    Orbit - left mouse / touch: one finger move\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\n//\n// This is a drop-in replacement for (most) TrackballControls used in examples.\n// That is, include this js file and wherever you see:\n//    \tcontrols = new THREE.TrackballControls( camera );\n//      controls.target.z = 150;\n// Simple substitute "OrbitControls" and the control should work as-is.\n\n\n\nfunction OrbitControls( object, domElement ) {\n\n\tthis.object = object;\n\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\n\n\t// API\n\n\t// Set to false to disable this control\n\tthis.enabled = true;\n\n\t// "target" sets the location of focus, where the control orbits around\n\t// and where it pans with respect to.\n\tthis.target = new external_THREE_["Vector3"]();\n\n\t// center is old, deprecated; use "target" instead\n\tthis.center = this.target;\n\n\t// This option actually enables dollying in and out; left as "zoom" for\n\t// backwards compatibility\n\tthis.noZoom = false;\n\tthis.zoomSpeed = 1.0;\n\n\t// Limits to how far you can dolly in and out\n\tthis.minDistance = 0;\n\tthis.maxDistance = Infinity;\n\n\t// Set to true to disable this control\n\tthis.noRotate = false;\n\tthis.rotateSpeed = 1.0;\n\n\t// Set to true to disable this control\n\tthis.noPan = false;\n\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\n\n\t// Set to true to automatically rotate around the target\n\tthis.autoRotate = false;\n\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n\t// How far you can orbit vertically, upper and lower limits.\n\t// Range is 0 to Math.PI radians.\n\tthis.minPolarAngle = 0; // radians\n\tthis.maxPolarAngle = Math.PI; // radians\n\n\t// Set to true to disable use of the keys\n\tthis.noKeys = false;\n\n\t// The four arrow keys\n\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\n\n\t////////////\n\t// internals\n\n\tvar scope = this;\n\n\tvar EPS = 0.000001;\n\n\tvar rotateStart = new external_THREE_["Vector2"]();\n\tvar rotateEnd = new external_THREE_["Vector2"]();\n\tvar rotateDelta = new external_THREE_["Vector2"]();\n\n\tvar panStart = new external_THREE_["Vector2"]();\n\tvar panEnd = new external_THREE_["Vector2"]();\n\tvar panDelta = new external_THREE_["Vector2"]();\n\tvar panOffset = new external_THREE_["Vector3"]();\n\n\tvar offset = new external_THREE_["Vector3"]();\n\n\tvar dollyStart = new external_THREE_["Vector2"]();\n\tvar dollyEnd = new external_THREE_["Vector2"]();\n\tvar dollyDelta = new external_THREE_["Vector2"]();\n\n\tvar phiDelta = 0;\n\tvar thetaDelta = 0;\n\tvar scale = 1;\n\tvar pan = new external_THREE_["Vector3"]();\n\n\tvar lastPosition = new external_THREE_["Vector3"]();\n\n\tvar STATE = { NONE : -1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };\n\n\tvar state = STATE.NONE;\n\n\t// for reset\n\n\tthis.target0 = this.target.clone();\n\tthis.position0 = this.object.position.clone();\n\n\t// events\n\n\tvar changeEvent = { type: \'change\' };\n\tvar startEvent = { type: \'start\'};\n\tvar endEvent = { type: \'end\'};\n\n\tthis.rotateLeft = function ( angle ) {\n\n\t\tif ( angle === undefined ) {\n\n\t\t\tangle = getAutoRotationAngle();\n\n\t\t}\n\n\t\tthetaDelta -= angle;\n\n\t};\n\n\tthis.rotateUp = function ( angle ) {\n\n\t\tif ( angle === undefined ) {\n\n\t\t\tangle = getAutoRotationAngle();\n\n\t\t}\n\n\t\tphiDelta -= angle;\n\n\t};\n\n\t// pass in distance in world space to move left\n\tthis.panLeft = function ( distance ) {\n\n\t\tvar te = this.object.matrix.elements;\n\n\t\t// get X column of matrix\n\t\tpanOffset.set( te[ 0 ], te[ 1 ], te[ 2 ] );\n\t\tpanOffset.multiplyScalar( - distance );\n\t\t\n\t\tpan.add( panOffset );\n\n\t};\n\n\t// pass in distance in world space to move up\n\tthis.panUp = function ( distance ) {\n\n\t\tvar te = this.object.matrix.elements;\n\n\t\t// get Y column of matrix\n\t\tpanOffset.set( te[ 4 ], te[ 5 ], te[ 6 ] );\n\t\tpanOffset.multiplyScalar( distance );\n\t\t\n\t\tpan.add( panOffset );\n\n\t};\n\t\n\t// pass in x,y of change desired in pixel space,\n\t// right and down are positive\n\tthis.pan = function ( deltaX, deltaY ) {\n\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\tif ( scope.object.fov !== undefined ) {\n\n\t\t\t// perspective\n\t\t\tvar position = scope.object.position;\n\t\t\tvar offset = position.clone().sub( scope.target );\n\t\t\tvar targetDistance = offset.length();\n\n\t\t\t// half of the fov is center to top of screen\n\t\t\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\n\n\t\t\t// we actually don\'t use screenWidth, since perspective camera is fixed to screen height\n\t\t\tscope.panLeft( 2 * deltaX * targetDistance / element.clientHeight );\n\t\t\tscope.panUp( 2 * deltaY * targetDistance / element.clientHeight );\n\n\t\t} else if ( scope.object.top !== undefined ) {\n            \n\t\t\t// orthographic\n\t\t\tscope.panLeft( deltaX * (scope.object.right - scope.object.left) / element.clientWidth );\n\t\t\tscope.panUp( deltaY * (scope.object.top - scope.object.bottom) / element.clientHeight );\n\n\t\t} else {\n\n\t\t\t// camera neither orthographic or perspective\n\t\t\tconsole.warn( \'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.\' );\n\n\t\t}\n\n\t};\n\n\tthis.dollyIn = function ( dollyScale ) {\n\n\t\tif ( dollyScale === undefined ) {\n\n\t\t\tdollyScale = getZoomScale();\n\n\t\t}\n\n\t\tscale /= dollyScale;\n\n\t};\n\n\tthis.dollyOut = function ( dollyScale ) {\n\n\t\tif ( dollyScale === undefined ) {\n\n\t\t\tdollyScale = getZoomScale();\n\n\t\t}\n\n\t\tscale *= dollyScale;\n\n\t};\n\n\tthis.update = function () {\n        \n        if(scope.object.top !== undefined) {\n            this.object.top = (scale*this.object.top);\n            this.object.bottom = (scale*this.object.bottom);\n            this.object.left = (scale*this.object.left);\n            this.object.right = (scale*this.object.right);\n            \n            this.object.updateProjectionMatrix();\n\n        }\n            \n\n\t\tvar position = this.object.position;\n\n\t\toffset.copy( position ).sub( this.target );\n//\n//\t\t// angle from z-axis around y-axis\n//\n//\t\tvar theta = Math.atan2( offset.x, offset.z );\n//\n//\t\t// angle from y-axis\n//\n//\t\tvar phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );\n//\n//\t\tif ( this.autoRotate ) {\n//\n//\t\t\tthis.rotateLeft( getAutoRotationAngle() );\n//\n//\t\t}\n//\n//\t\ttheta += thetaDelta;\n//\t\tphi += phiDelta;\n//\n//\t\t// restrict phi to be between desired limits\n//\t\tphi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );\n//\n//\t\t// restrict phi to be betwee EPS and PI-EPS\n//\t\tphi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );\n//\n//\t\tvar radius = offset.length() * scale;\n//\n//\t\t// restrict radius to be between desired limits\n//\t\tradius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );\n//\t\t\n//\t\t// move target to panned location\n\t\tthis.target.add( pan );\n//\t\t\n//\t\toffset.x = radius * Math.sin( phi ) * Math.sin( theta );\n//\t\toffset.y = radius * Math.cos( phi );\n//\t\toffset.z = radius * Math.sin( phi ) * Math.cos( theta );\n//\n\t\tposition.copy( this.target ).add( offset );\n\n\t\tthis.object.lookAt( this.target );\n\n\n//\t\tif ( lastPosition.distanceTo( this.object.position ) > 0 || scale !== 1 ) {\n\n\t\t\tthis.dispatchEvent( changeEvent );\n\n//\t\t\tlastPosition.copy( this.object.position );\n\n//\t\t}\n        \n//        thetaDelta = 0;\n//\t\tphiDelta = 0;\n\t\tscale = 1;\n\t\tpan.set( 0, 0, 0 );\n\n\t};\n\n\n\tthis.reset = function () {\n\n\t\tstate = STATE.NONE;\n\n\t\tthis.target.copy( this.target0 );\n\t\tthis.object.position.copy( this.position0 );\n\n\t\tthis.update();\n\n\t};\n\n\tfunction getAutoRotationAngle() {\n\n\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n\t}\n\n\tfunction getZoomScale() {\n\n\t\treturn Math.pow( 0.95, scope.zoomSpeed );\n\n\t}\n\n\tfunction onMouseDown( event ) {\n\n\t\tif ( scope.enabled === false ) return;\n\t\tevent.preventDefault();\n\n\t\tif ( event.button === 0 ) {\n\t\t\tif ( scope.noRotate === true ) return;\n\n\t\t\tstate = STATE.ROTATE;\n\n\t\t\trotateStart.set( event.clientX, event.clientY );\n\n\t\t} else if ( event.button === 1 ) {\n\t\t\tif ( scope.noZoom === true ) return;\n\n\t\t\tstate = STATE.DOLLY;\n\n\t\t\tdollyStart.set( event.clientX, event.clientY );\n\n\t\t} else if ( event.button === 2 ) {\n\t\t\tif ( scope.noPan === true ) return;\n\n\t\t\tstate = STATE.PAN;\n\n\t\t\tpanStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tscope.domElement.addEventListener( \'mousemove\', onMouseMove, false );\n\t\tscope.domElement.addEventListener( \'mouseup\', onMouseUp, false );\n\t\tscope.dispatchEvent( startEvent );\n\n\t}\n\n\tfunction onMouseMove( event ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\tif ( state === STATE.ROTATE ) {\n\n\t\t\tif ( scope.noRotate === true ) return;\n\n\t\t\trotateEnd.set( event.clientX, event.clientY );\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\n\t\t\t// rotating across whole screen goes 360 degrees around\n\t\t\tscope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\n\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\t\tscope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\n\t\t\trotateStart.copy( rotateEnd );\n\n\t\t} else if ( state === STATE.DOLLY ) {\n\n\t\t\tif ( scope.noZoom === true ) return;\n\n\t\t\tdollyEnd.set( event.clientX, event.clientY );\n\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\tscope.dollyIn();\n\n\t\t\t} else {\n\n\t\t\t\tscope.dollyOut();\n\n\t\t\t}\n\n\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t} else if ( state === STATE.PAN ) {\n\n\t\t\tif ( scope.noPan === true ) return;\n\n\t\t\tpanEnd.set( event.clientX, event.clientY );\n\t\t\tpanDelta.subVectors( panEnd, panStart );\n\t\t\t\n\t\t\tscope.pan( panDelta.x, panDelta.y );\n\n\t\t\tpanStart.copy( panEnd );\n\n\t\t}\n\n\t\tscope.update();\n\n\t}\n\n\tfunction onMouseUp( /* event */ ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\tscope.domElement.removeEventListener( \'mousemove\', onMouseMove, false );\n\t\tscope.domElement.removeEventListener( \'mouseup\', onMouseUp, false );\n\t\tscope.dispatchEvent( endEvent );\n\t\tstate = STATE.NONE;\n\n\t}\n\n\tfunction onMouseWheel( event ) {\n\n\t\tif ( scope.enabled === false || scope.noZoom === true ) return;\n\n\t\tevent.preventDefault();\n\n\t\tvar delta = 0;\n\n\t\tif ( event.wheelDelta !== undefined ) { // WebKit / Opera / Explorer 9\n\n\t\t\tdelta = event.wheelDelta;\n\n\t\t} else if ( event.detail !== undefined ) { // Firefox\n\n\t\t\tdelta = - event.detail;\n\n\t\t}\n\n\t\tif ( delta > 0 ) {\n\n\t\t\tscope.dollyOut();\n\n\t\t} else {\n\n\t\t\tscope.dollyIn();\n\n\t\t}\n\n\t\tscope.update();\n\t\tscope.dispatchEvent( startEvent );\n\t\tscope.dispatchEvent( endEvent );\n\n\t}\n\n\tfunction onKeyDown( event ) {\n\n\t\tif ( scope.enabled === false || scope.noKeys === true || scope.noPan === true ) return;\n\t\t\n\t\tswitch ( event.keyCode ) {\n\n\t\t\tcase scope.keys.UP:\n\t\t\t\tscope.pan( 0, scope.keyPanSpeed );\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tcase scope.keys.BOTTOM:\n\t\t\t\tscope.pan( 0, - scope.keyPanSpeed );\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tcase scope.keys.LEFT:\n\t\t\t\tscope.pan( scope.keyPanSpeed, 0 );\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tcase scope.keys.RIGHT:\n\t\t\t\tscope.pan( - scope.keyPanSpeed, 0 );\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\tfunction touchstart( event ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\tswitch ( event.touches.length ) {\n\n\t\t\tcase 1:\t// one-fingered touch: rotate\n\n\t\t\t\tif ( scope.noRotate === true ) return;\n\n\t\t\t\tstate = STATE.TOUCH_ROTATE;\n\n\t\t\t\trotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\t// two-fingered touch: dolly\n\n\t\t\t\tif ( scope.noZoom === true ) return;\n\n\t\t\t\tstate = STATE.TOUCH_DOLLY;\n\n\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\t\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\t\t\t\tdollyStart.set( 0, distance );\n\t\t\t\tbreak;\n\n\t\t\tcase 3: // three-fingered touch: pan\n\n\t\t\t\tif ( scope.noPan === true ) return;\n\n\t\t\t\tstate = STATE.TOUCH_PAN;\n\n\t\t\t\tpanStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t\tscope.dispatchEvent( startEvent );\n\n\t}\n\n\tfunction touchmove( event ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\tswitch ( event.touches.length ) {\n\n\t\t\tcase 1: // one-fingered touch: rotate\n\n\t\t\t\tif ( scope.noRotate === true ) return;\n\t\t\t\tif ( state !== STATE.TOUCH_ROTATE ) return;\n\n\t\t\t\trotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\n\t\t\t\t// rotating across whole screen goes 360 degrees around\n\t\t\t\tscope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\t\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\t\t\tscope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\n\t\t\t\trotateStart.copy( rotateEnd );\n\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tcase 2: // two-fingered touch: dolly\n\n\t\t\t\tif ( scope.noZoom === true ) return;\n\t\t\t\tif ( state !== STATE.TOUCH_DOLLY ) return;\n\n\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\t\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\t\tdollyEnd.set( 0, distance );\n\t\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\t\tscope.dollyOut();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tscope.dollyIn();\n\n\t\t\t\t}\n\n\t\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tcase 3: // three-fingered touch: pan\n\n\t\t\t\tif ( scope.noPan === true ) return;\n\t\t\t\tif ( state !== STATE.TOUCH_PAN ) return;\n\n\t\t\t\tpanEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\tpanDelta.subVectors( panEnd, panStart );\n\t\t\t\t\n\t\t\t\tscope.pan( panDelta.x, panDelta.y );\n\n\t\t\t\tpanStart.copy( panEnd );\n\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t}\n\n\tfunction touchend( /* event */ ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\tscope.dispatchEvent( endEvent );\n\t\tstate = STATE.NONE;\n\n\t}\n\n\tthis.domElement.addEventListener( \'contextmenu\', function ( event ) { event.preventDefault(); }, false );\n\tthis.domElement.addEventListener( \'mousedown\', onMouseDown, false );\n\tthis.domElement.addEventListener( \'mousewheel\', onMouseWheel, false );\n\tthis.domElement.addEventListener( \'DOMMouseScroll\', onMouseWheel, false ); // firefox\n\n\tthis.domElement.addEventListener( \'touchstart\', touchstart, false );\n\tthis.domElement.addEventListener( \'touchend\', touchend, false );\n\tthis.domElement.addEventListener( \'touchmove\', touchmove, false );\n\n\twindow.addEventListener( \'keydown\', onKeyDown, false );\n\n};\n\nOrbitControls.prototype = Object.create( external_THREE_["EventDispatcher"].prototype );\n// CONCATENATED MODULE: ./src/index.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Viewer", function() { return Viewer; });\n\n\n\n// Three.js extension functions. Webpack doesn\'t seem to like it if we modify the THREE object directly.\nvar THREEx = { Math: {} };\n/**\n * Returns the angle in radians of the vector (p1,p2). In other words, imagine\n * putting the base of the vector at coordinates (0,0) and finding the angle\n * from vector (1,0) to (p1,p2).\n * @param  {Object} p1 start point of the vector\n * @param  {Object} p2 end point of the vector\n * @return {Number} the angle\n */\nTHREEx.Math.angle2 = function(p1, p2) {\n\tvar v1 = new external_THREE_["Vector2"](p1.x, p1.y);\n\tvar v2 = new external_THREE_["Vector2"](p2.x, p2.y);\n\tv2.sub(v1); // sets v2 to be our chord\n\tv2.normalize();\n\tif(v2.y < 0) return -Math.acos(v2.x);\n\treturn Math.acos(v2.x);\n};\n\n\nTHREEx.Math.polar = function(point, distance, angle) {\n\tvar result = {};\n\tresult.x = point.x + distance * Math.cos(angle);\n\tresult.y = point.y + distance * Math.sin(angle);\n\treturn result;\n};\n\n/**\n * Calculates points for a curve between two points\n * @param startPoint - the starting point of the curve\n * @param endPoint - the ending point of the curve\n * @param bulge - a value indicating how much to curve\n * @param segments - number of segments between the two given points\n */\nTHREEx.BulgeGeometry = function ( startPoint, endPoint, bulge, segments ) {\n\n\tvar vertex, i,\n\t\tcenter, p0, p1, angle,\n\t\tradius, startAngle,\n\t\tthetaAngle;\n\n\texternal_THREE_["Geometry"].call( this );\n\n\tthis.startPoint = p0 = startPoint ? new external_THREE_["Vector2"](startPoint.x, startPoint.y) : new external_THREE_["Vector2"](0,0);\n\tthis.endPoint = p1 = endPoint ? new external_THREE_["Vector2"](endPoint.x, endPoint.y) : new external_THREE_["Vector2"](1,0);\n\tthis.bulge = bulge = bulge || 1;\n\n\tangle = 4 * Math.atan(bulge);\n\tradius = p0.distanceTo(p1) / 2 / Math.sin(angle/2);\n\tcenter = THREEx.Math.polar(startPoint, radius, THREEx.Math.angle2(p0,p1) + (Math.PI / 2 - angle/2));\n\n\tthis.segments = segments = segments || Math.max( Math.abs(Math.ceil(angle/(Math.PI/18))), 6); // By default want a segment roughly every 10 degrees\n\tstartAngle = THREEx.Math.angle2(center, p0);\n\tthetaAngle = angle / segments;\n\n\n\tthis.vertices.push(new external_THREE_["Vector3"](p0.x, p0.y, 0));\n\n\tfor(i = 1; i <= segments - 1; i++) {\n\n\t\tvertex = THREEx.Math.polar(center, Math.abs(radius), startAngle + thetaAngle * i);\n\n\t\tthis.vertices.push(new external_THREE_["Vector3"](vertex.x, vertex.y, 0));\n\n\t}\n\n};\n\nTHREEx.BulgeGeometry.prototype = Object.create( external_THREE_["Geometry"].prototype );\n    \n/**\n * Viewer class for a dxf object.\n * @param {Object} data - the dxf object\n * @param {Object} parent - the parent element to which we attach the rendering canvas\n * @param {Number} width - width of the rendering canvas in pixels\n * @param {Number} height - height of the rendering canvas in pixels\n * @param {Object} font - a font loaded with THREE.FontLoader \n * @constructor\n */\nfunction Viewer(data, parent, width, height, font) {\n\n    createLineTypeShaders(data);\n\n    var scene = new external_THREE_["Scene"]();\n\n    // Create scene from dxf object (data)\n    var i, entity, obj, min_x, min_y, min_z, max_x, max_y, max_z;\n    var dims = {\n        min: { x: false, y: false, z: false},\n        max: { x: false, y: false, z: false}\n    };\n    for(i = 0; i < data.entities.length; i++) {\n        entity = data.entities[i];\n        obj = drawEntity(entity, data);\n\n        if (obj) {\n            var bbox = new external_THREE_["Box3"]().setFromObject(obj);\n            if (bbox.min.x && ((dims.min.x === false) || (dims.min.x > bbox.min.x))) dims.min.x = bbox.min.x;\n            if (bbox.min.y && ((dims.min.y === false) || (dims.min.y > bbox.min.y))) dims.min.y = bbox.min.y;\n            if (bbox.min.z && ((dims.min.z === false) || (dims.min.z > bbox.min.z))) dims.min.z = bbox.min.z;\n            if (bbox.max.x && ((dims.max.x === false) || (dims.max.x < bbox.max.x))) dims.max.x = bbox.max.x;\n            if (bbox.max.y && ((dims.max.y === false) || (dims.max.y < bbox.max.y))) dims.max.y = bbox.max.y;\n            if (bbox.max.z && ((dims.max.z === false) || (dims.max.z < bbox.max.z))) dims.max.z = bbox.max.z;\n            scene.add(obj);\n        }\n        obj = null;\n    }\n\n    width = width || parent.innerWidth;\n    height = height || parent.innerHeight;\n    var aspectRatio = width / height;\n\n    var upperRightCorner = { x: dims.max.x, y: dims.max.y };\n    var lowerLeftCorner = { x: dims.min.x, y: dims.min.y };\n\n    // Figure out the current viewport extents\n    var vp_width = upperRightCorner.x - lowerLeftCorner.x;\n    var vp_height = upperRightCorner.y - lowerLeftCorner.y;\n    var center = center || {\n        x: vp_width / 2 + lowerLeftCorner.x,\n        y: vp_height / 2 + lowerLeftCorner.y\n    };\n\n    // Fit all objects into current ThreeDXF viewer\n    var extentsAspectRatio = Math.abs(vp_width / vp_height);\n    if (aspectRatio > extentsAspectRatio) {\n        vp_width = vp_height * aspectRatio;\n    } else {\n        vp_height = vp_width / aspectRatio;\n    }\n    \n    var viewPort = {\n        bottom: -vp_height / 2,\n        left: -vp_width / 2,\n        top: vp_height / 2,\n        right: vp_width / 2,\n        center: {\n            x: center.x,\n            y: center.y\n        }\n    };\n\n    var camera = new external_THREE_["OrthographicCamera"](viewPort.left, viewPort.right, viewPort.top, viewPort.bottom, 1, 19);\n    camera.position.z = 10;\n    camera.position.x = viewPort.center.x;\n    camera.position.y = viewPort.center.y;\n\n    var renderer = this.renderer = new external_THREE_["WebGLRenderer"]();\n    renderer.setSize(width, height);\n    renderer.setClearColor(0xfffffff, 1);\n\n    parent.appendChild(renderer.domElement);\n    parent.style.display = \'block\';\n\n    //TODO: Need to make this an option somehow so others can roll their own controls.\n    var controls = new OrbitControls(camera, parent);\n    controls.target.x = camera.position.x;\n    controls.target.y = camera.position.y;\n    controls.target.z = 0;\n    controls.zoomSpeed = 3;\n\n    //Uncomment this to disable rotation (does not make much sense with 2D drawings).\n    //controls.enableRotate = false;\n\n    this.render = function() { renderer.render(scene, camera) };\n    controls.addEventListener(\'change\', this.render);\n    this.render();\n    controls.update();\n\n    this.resize = function(width, height) {\n        var originalWidth = renderer.domElement.width;\n        var originalHeight = renderer.domElement.height;\n\n        var hscale = width / originalWidth;\n        var vscale = height / originalHeight;\n\n\n        camera.top = (vscale * camera.top);\n        camera.bottom = (vscale * camera.bottom);\n        camera.left = (hscale * camera.left);\n        camera.right = (hscale * camera.right);\n\n//        camera.updateProjectionMatrix();\n\n        renderer.setSize(width, height);\n        renderer.setClearColor(0xfffffff, 1);\n        this.render();\n    };\n\n    function drawEntity(entity, data) {\n        var mesh;\n        if(entity.type === \'CIRCLE\' || entity.type === \'ARC\') {\n            mesh = drawArc(entity, data);\n        } else if(entity.type === \'LWPOLYLINE\' || entity.type === \'LINE\' || entity.type === \'POLYLINE\') {\n            mesh = drawLine(entity, data);\n        } else if(entity.type === \'TEXT\') {\n            mesh = drawText(entity, data);\n        } else if(entity.type === \'SOLID\') {\n            mesh = drawSolid(entity, data);\n        } else if(entity.type === \'POINT\') {\n            mesh = drawPoint(entity, data);\n        } else if(entity.type === \'INSERT\') {\n            mesh = drawBlock(entity, data);\n        } else if(entity.type === \'SPLINE\') {\n            mesh = drawSpline(entity, data);\n        } else if(entity.type === \'MTEXT\') {\n            mesh = drawMtext(entity, data);\n        } else if(entity.type === \'ELLIPSE\') {\n            mesh = drawEllipse(entity, data);\n        } else if(entity.type === \'DIMENSION\') {\n            var dimTypeEnum = entity.dimensionType & 7;\n            if(dimTypeEnum === 0) {\n                mesh = drawDimension(entity, data);\n            } else {\n                console.log("Unsupported Dimension type: " + dimTypeEnum);\n            }\n        }\n        else {\n            console.log("Unsupported Entity Type: " + entity.type);\n        }\n        return mesh;\n    }\n\n    function drawEllipse(entity, data) {\n        var color = getColor(entity, data);\n\n        var xrad = Math.sqrt(Math.pow(entity.majorAxisEndPoint.x,2) + Math.pow(entity.majorAxisEndPoint.y,2));\n        var yrad = xrad*entity.axisRatio;\n        var rotation = Math.atan2(entity.majorAxisEndPoint.y, entity.majorAxisEndPoint.x);\n\n        var curve = new external_THREE_["EllipseCurve"](\n            entity.center.x,  entity.center.y,\n            xrad, yrad,\n            entity.startAngle, entity.endAngle,\n            false, // Always counterclockwise\n            rotation\n        );\n\n        var points = curve.getPoints( 50 );\n        var geometry = new external_THREE_["BufferGeometry"]().setFromPoints( points );\n        var material = new external_THREE_["LineBasicMaterial"]( {  linewidth: 1, color : color } );\n\n        // Create the final object to add to the scene\n        var ellipse = new external_THREE_["Line"]( geometry, material );\n        return ellipse;\n    }\n\n    function drawMtext(entity, data) {\n        var color = getColor(entity, data);\n\n        var geometry = new external_THREE_["TextGeometry"]( entity.text, {\n            font: font,\n            size: entity.height * (4/5),\n            height: 1\n        });\n        var material = new external_THREE_["MeshBasicMaterial"]( {color: color} );\n        var text = new external_THREE_["Mesh"]( geometry, material );\n\n        // Measure what we rendered.\n        var measure = new external_THREE_["Box3"]();\n        measure.setFromObject( text );\n\n        var textWidth  = measure.max.x - measure.min.x;\n\n        // If the text ends up being wider than the box, it\'s supposed\n        // to be multiline. Doing that in threeJS is overkill.\n        if (textWidth > entity.width) {\n            console.log("Can\'t render this multipline MTEXT entity, sorry.", entity);\n            return undefined;\n        }\n\n        text.position.z = 0;\n        switch (entity.attachmentPoint) {\n            case 1:\n                // Top Left\n                text.position.x = entity.position.x;\n                text.position.y = entity.position.y - entity.height;\n            break;\n            case 2:\n                // Top Center\n                text.position.x = entity.position.x - textWidth/2;\n                text.position.y = entity.position.y - entity.height;\n            break;\n            case 3:\n                // Top Right\n                text.position.x = entity.position.x - textWidth;\n                text.position.y = entity.position.y - entity.height;\n            break;\n\n            case 4:\n                // Middle Left\n                text.position.x = entity.position.x;\n                text.position.y = entity.position.y - entity.height/2;\n            break;\n            case 5:\n                // Middle Center\n                text.position.x = entity.position.x - textWidth/2;\n                text.position.y = entity.position.y - entity.height/2;\n            break;\n            case 6:\n                // Middle Right\n                text.position.x = entity.position.x - textWidth;\n                text.position.y = entity.position.y - entity.height/2;\n            break;\n\n            case 7:\n                // Bottom Left\n                text.position.x = entity.position.x;\n                text.position.y = entity.position.y;\n            break;\n            case 8:\n                // Bottom Center\n                text.position.x = entity.position.x - textWidth/2;\n                text.position.y = entity.position.y;\n            break;\n            case 9:\n                // Bottom Right\n                text.position.x = entity.position.x - textWidth;\n                text.position.y = entity.position.y;\n            break;\n\n            default:\n                return undefined;\n        };\n\n        return text;\n    }\n\n    function drawSpline(entity, data) {\n        var color = getColor(entity, data);\n\n        var points = entity.controlPoints.map(function(vec) {\n            return new external_THREE_["Vector2"](vec.x, vec.y);\n        });\n\n        var interpolatedPoints = [];\n        var curve;\n        if (entity.degreeOfSplineCurve === 2 || entity.degreeOfSplineCurve === 3) {\n            for(var i = 0; i + 2 < points.length; i = i + 2) {\n        if (entity.degreeOfSplineCurve === 2) {\n                        curve = new external_THREE_["QuadraticBezierCurve"](points[i], points[i + 1], points[i + 2]);\n        } else {\n            curve = new external_THREE_["QuadraticBezierCurve3"](points[i], points[i + 1], points[i + 2]);\n        }\n                interpolatedPoints.push.apply(interpolatedPoints, curve.getPoints(50));\n            }\n        } else {\n            curve = new external_THREE_["SplineCurve"](points);\n            interpolatedPoints = curve.getPoints( 100 );\n        }\n\n        var geometry = new external_THREE_["BufferGeometry"]().setFromPoints( interpolatedPoints );\n        var material = new external_THREE_["LineBasicMaterial"]( { linewidth: 1, color : color } );\n        var splineObject = new external_THREE_["Line"]( geometry, material );\n\n        return splineObject;\n    }\n\n    function drawLine(entity, data) {\n        var geometry = new external_THREE_["Geometry"](),\n            color = getColor(entity, data),\n            material, lineType, vertex, startPoint, endPoint, bulgeGeometry,\n            bulge, i, line;\n\n        // create geometry\n        for(i = 0; i < entity.vertices.length; i++) {\n\n            if(entity.vertices[i].bulge) {\n                bulge = entity.vertices[i].bulge;\n                startPoint = entity.vertices[i];\n                endPoint = i + 1 < entity.vertices.length ? entity.vertices[i + 1] : geometry.vertices[0];\n\n                bulgeGeometry = new THREEx.BulgeGeometry(startPoint, endPoint, bulge);\n\n                geometry.vertices.push.apply(geometry.vertices, bulgeGeometry.vertices);\n            } else {\n                vertex = entity.vertices[i];\n                geometry.vertices.push(new external_THREE_["Vector3"](vertex.x, vertex.y, 0));\n            }\n\n        }\n        if(entity.shape) geometry.vertices.push(geometry.vertices[0]);\n\n\n        // set material\n        if(entity.lineType) {\n            lineType = data.tables.lineType.lineTypes[entity.lineType];\n        }\n\n        if(lineType && lineType.pattern && lineType.pattern.length !== 0) {\n            material = new external_THREE_["LineDashedMaterial"]({ color: color, gapSize: 4, dashSize: 4});\n        } else {\n            material = new external_THREE_["LineBasicMaterial"]({ linewidth: 1, color: color });\n        }\n\n        // if(lineType && lineType.pattern && lineType.pattern.length !== 0) {\n\n        //           geometry.computeLineDistances();\n\n        //           // Ugly hack to add diffuse to this. Maybe copy the uniforms object so we\n        //           // don\'t add diffuse to a material.\n        //           lineType.material.uniforms.diffuse = { type: \'c\', value: new THREE.Color(color) };\n\n        // \tmaterial = new THREE.ShaderMaterial({\n        // \t\tuniforms: lineType.material.uniforms,\n        // \t\tvertexShader: lineType.material.vertexShader,\n        // \t\tfragmentShader: lineType.material.fragmentShader\n        // \t});\n        // }else {\n        // \tmaterial = new THREE.LineBasicMaterial({ linewidth: 1, color: color });\n        // }\n\n        line = new external_THREE_["Line"](geometry, material);\n        return line;\n    }\n    \n    function drawArc(entity, data) {\n        var startAngle, endAngle;\n        if (entity.type === \'CIRCLE\') {\n            startAngle = entity.startAngle || 0;\n            endAngle = startAngle + 2 * Math.PI;\n        } else {\n            startAngle = entity.startAngle;\n            endAngle = entity.endAngle;\n        }\n\n        var curve = new external_THREE_["ArcCurve"](\n            0, 0,\n            entity.radius,\n            startAngle,\n            endAngle);\n\n        var points = curve.getPoints( 32 );\n        var geometry = new external_THREE_["BufferGeometry"]().setFromPoints( points );\n\n        var material = new external_THREE_["LineBasicMaterial"]({ color: getColor(entity, data) });\n\n        var arc = new external_THREE_["Line"](geometry, material);\n        arc.position.x = entity.center.x;\n        arc.position.y = entity.center.y;\n        arc.position.z = entity.center.z;\n\n        return arc;\n    }\n\n    function drawSolid(entity, data) {\n        var material, mesh, verts,\n            geometry = new external_THREE_["Geometry"]();\n\n        verts = geometry.vertices;\n        verts.push(new external_THREE_["Vector3"](entity.points[0].x, entity.points[0].y, entity.points[0].z));\n        verts.push(new external_THREE_["Vector3"](entity.points[1].x, entity.points[1].y, entity.points[1].z));\n        verts.push(new external_THREE_["Vector3"](entity.points[2].x, entity.points[2].y, entity.points[2].z));\n        verts.push(new external_THREE_["Vector3"](entity.points[3].x, entity.points[3].y, entity.points[3].z));\n\n        // Calculate which direction the points are facing (clockwise or counter-clockwise)\n        var vector1 = new external_THREE_["Vector3"]();\n        var vector2 = new external_THREE_["Vector3"]();\n        vector1.subVectors(verts[1], verts[0]);\n        vector2.subVectors(verts[2], verts[0]);\n        vector1.cross(vector2);\n\n        // If z < 0 then we must draw these in reverse order\n        if(vector1.z < 0) {\n            geometry.faces.push(new external_THREE_["Face3"](2, 1, 0));\n            geometry.faces.push(new external_THREE_["Face3"](2, 3, 1));\n        } else {\n            geometry.faces.push(new external_THREE_["Face3"](0, 1, 2));\n            geometry.faces.push(new external_THREE_["Face3"](1, 3, 2));\n        }\n\n\n        material = new external_THREE_["MeshBasicMaterial"]({ color: getColor(entity, data) });\n\n        return new external_THREE_["Mesh"](geometry, material);\n        \n    }\n\n    function drawText(entity, data) {\n        var geometry, material, text;\n\n        if(!font)\n            return console.warn(\'Text is not supported without a Three.js font loaded with THREE.FontLoader! Load a font of your choice and pass this into the constructor. See the sample for this repository or Three.js examples at http://threejs.org/examples/?q=text#webgl_geometry_text for more details.\');\n        \n        geometry = new external_THREE_["TextGeometry"](entity.text, { font: font, height: 0, size: entity.textHeight || 12 });\n\n        if (entity.rotation) {\n            var zRotation = entity.rotation * Math.PI / 180;\n            geometry.rotateZ(zRotation);\n        }\n\n        material = new external_THREE_["MeshBasicMaterial"]({ color: getColor(entity, data) });\n\n        text = new external_THREE_["Mesh"](geometry, material);\n        text.position.x = entity.startPoint.x;\n        text.position.y = entity.startPoint.y;\n        text.position.z = entity.startPoint.z;\n\n        return text;\n    }\n\n    function drawPoint(entity, data) {\n        var geometry, material, point;\n\n        geometry = new external_THREE_["Geometry"]();\n\n        geometry.vertices.push(new external_THREE_["Vector3"](entity.position.x, entity.position.y, entity.position.z));\n\n        // TODO: could be more efficient. PointCloud per layer?\n\n        var numPoints = 1;\n\n        var color = getColor(entity, data);\n        var colors = new Float32Array( numPoints*3 );\n        colors[0] = color.r;\n        colors[1] = color.g;\n        colors[2] = color.b;\n\n        geometry.colors = colors;\n        geometry.computeBoundingBox();\n\n        material = new external_THREE_["PointsMaterial"]( { size: 0.05, vertexColors: external_THREE_["VertexColors"] } );\n        point = new external_THREE_["Points"](geometry, material);\n        scene.add(point);\n    }\n\n    function drawDimension(entity, data) {\n        var block = data.blocks[entity.block];\n\n        if (!block || !block.entities) return null;\n\n        var group = new external_THREE_["Object3D"]();\n        // if(entity.anchorPoint) {\n        //     group.position.x = entity.anchorPoint.x;\n        //     group.position.y = entity.anchorPoint.y;\n        //     group.position.z = entity.anchorPoint.z;\n        // }\n\n        for(var i = 0; i < block.entities.length; i++) {\n            var childEntity = drawEntity(block.entities[i], data, group);\n            if(childEntity) group.add(childEntity);\n        }\n\n        return group;\n    }\n\n    function drawBlock(entity, data) {\n        var block = data.blocks[entity.name];\n        \n        if (!block.entities) return null;\n\n        var group = new external_THREE_["Object3D"]()\n        \n        if(entity.xScale) group.scale.x = entity.xScale;\n        if(entity.yScale) group.scale.y = entity.yScale;\n\n        if(entity.rotation) {\n            group.rotation.z = entity.rotation * Math.PI / 180;\n        }\n\n        if(entity.position) {\n            group.position.x = entity.position.x;\n            group.position.y = entity.position.y;\n            group.position.z = entity.position.z;\n        }\n        \n        for(var i = 0; i < block.entities.length; i++) {\n            var childEntity = drawEntity(block.entities[i], data, group);\n            if(childEntity) group.add(childEntity);\n        }\n\n        return group;\n    }\n\n    function getColor(entity, data) {\n        var color = 0x000000; //default\n        if(entity.color) color = entity.color;\n        else if(data.tables && data.tables.layer && data.tables.layer.layers[entity.layer])\n            color = data.tables.layer.layers[entity.layer].color;\n            \n        if(color == null || color === 0xffffff) {\n            color = 0x000000;\n        }\n        return color;\n    }\n\n    function createLineTypeShaders(data) {\n        var ltype, type;\n        if(!data.tables || !data.tables.lineType) return;\n        var ltypes = data.tables.lineType.lineTypes;\n\n        for(type in ltypes) {\n            ltype = ltypes[type];\n            if(!ltype.pattern) continue;\n            ltype.material = createDashedLineShader(ltype.pattern);\n        }\n    }\n\n    function createDashedLineShader(pattern) {\n        var i,\n            dashedLineShader = {},\n            totalLength = 0.0;\n\n        for(i = 0; i < pattern.length; i++) {\n            totalLength += Math.abs(pattern[i]);\n        }\n\n        dashedLineShader.uniforms = external_THREE_["UniformsUtils"].merge([\n\n            external_THREE_["UniformsLib"][ \'common\' ],\n            external_THREE_["UniformsLib"][ \'fog\' ],\n\n            {\n                \'pattern\': { type: \'fv1\', value: pattern },\n                \'patternLength\': { type: \'f\', value: totalLength }\n            }\n\n        ]);\n\n        dashedLineShader.vertexShader = [\n            \'attribute float lineDistance;\',\n\n            \'varying float vLineDistance;\',\n\n            external_THREE_["ShaderChunk"][ \'color_pars_vertex\' ],\n\n            \'void main() {\',\n\n            external_THREE_["ShaderChunk"][ \'color_vertex\' ],\n\n            \'vLineDistance = lineDistance;\',\n\n            \'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\',\n\n            \'}\'\n        ].join(\'\\n\');\n\n        dashedLineShader.fragmentShader = [\n            \'uniform vec3 diffuse;\',\n            \'uniform float opacity;\',\n\n            \'uniform float pattern[\' + pattern.length + \'];\',\n            \'uniform float patternLength;\',\n\n            \'varying float vLineDistance;\',\n\n            external_THREE_["ShaderChunk"][ \'color_pars_fragment\' ],\n            external_THREE_["ShaderChunk"][ \'fog_pars_fragment\' ],\n\n            \'void main() {\',\n\n            \'float pos = mod(vLineDistance, patternLength);\',\n\n            \'for ( int i = 0; i < \' + pattern.length + \'; i++ ) {\',\n            \'pos = pos - abs(pattern[i]);\',\n            \'if( pos < 0.0 ) {\',\n            \'if( pattern[i] > 0.0 ) {\',\n            \'gl_FragColor = vec4(1.0, 0.0, 0.0, opacity );\',\n            \'break;\',\n            \'}\',\n            \'discard;\',\n            \'}\',\n\n            \'}\',\n\n            external_THREE_["ShaderChunk"][ \'color_fragment\' ],\n            external_THREE_["ShaderChunk"][ \'fog_fragment\' ],\n\n            \'}\'\n        ].join(\'\\n\');\n\n        return dashedLineShader;\n    }\n\n    function findExtents(scene) { \n        for(var child of scene.children) {\n            var minX, maxX, minY, maxY;\n            if(child.position) {\n                minX = Math.min(child.position.x, minX);\n                minY = Math.min(child.position.y, minY);\n                maxX = Math.max(child.position.x, maxX);\n                maxY = Math.max(child.position.y, maxY);\n            }\n        }\n\n        return { min: { x: minX, y: minY }, max: { x: maxX, y: maxY }};\n    }\n\n}\n\n\n// Show/Hide helpers from https://plainjs.com/javascript/effects/hide-or-show-an-element-42/\n// get the default display style of an element\nfunction defaultDisplay(tag) {\n    var iframe = document.createElement(\'iframe\');\n    iframe.setAttribute(\'frameborder\', 0);\n    iframe.setAttribute(\'width\', 0);\n    iframe.setAttribute(\'height\', 0);\n    document.documentElement.appendChild(iframe);\n\n    var doc = (iframe.contentWindow || iframe.contentDocument).document;\n\n    // IE support\n    doc.write();\n    doc.close();\n\n    var testEl = doc.createElement(tag);\n    doc.documentElement.appendChild(testEl);\n    var display = (window.getComputedStyle ? getComputedStyle(testEl, null) : testEl.currentStyle).display\n    iframe.parentNode.removeChild(iframe);\n    return display;\n}\n\n// actual show/hide function used by show() and hide() below\nfunction showHide(el, show) {\n    var value = el.getAttribute(\'data-olddisplay\'),\n    display = el.style.display,\n    computedDisplay = (window.getComputedStyle ? getComputedStyle(el, null) : el.currentStyle).display;\n\n    if (show) {\n        if (!value && display === \'none\') el.style.display = \'\';\n        if (el.style.display === \'\' && (computedDisplay === \'none\')) value = value || defaultDisplay(el.nodeName);\n    } else {\n        if (display && display !== \'none\' || !(computedDisplay == \'none\'))\n            el.setAttribute(\'data-olddisplay\', (computedDisplay == \'none\') ? display : computedDisplay);\n    }\n    if (!show || el.style.display === \'none\' || el.style.display === \'\')\n        el.style.display = show ? value || \'\' : \'none\';\n}\n\n// helper functions\nfunction show(el) { showHide(el, true); }\nfunction hide(el) { showHide(el); }\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9UaHJlZUR4Zi8uL3NyYy9PcmJpdENvbnRyb2xzLmpzP2UyMGYiLCJ3ZWJwYWNrOi8vVGhyZWVEeGYvLi9zcmMvaW5kZXguanM/YjYzNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUrQjs7QUFFeEI7O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsMEJBQWE7O0FBRWhDLDhCQUE4QjtBQUM5Qjs7QUFFQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qiw4QkFBOEI7O0FBRTlCO0FBQ0E7O0FBRUE7QUFDQSxjQUFjOztBQUVkO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLDBCQUFhO0FBQ3BDLHFCQUFxQiwwQkFBYTtBQUNsQyx1QkFBdUIsMEJBQWE7O0FBRXBDLG9CQUFvQiwwQkFBYTtBQUNqQyxrQkFBa0IsMEJBQWE7QUFDL0Isb0JBQW9CLDBCQUFhO0FBQ2pDLHFCQUFxQiwwQkFBYTs7QUFFbEMsa0JBQWtCLDBCQUFhOztBQUUvQixzQkFBc0IsMEJBQWE7QUFDbkMsb0JBQW9CLDBCQUFhO0FBQ2pDLHNCQUFzQiwwQkFBYTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBYTs7QUFFNUIsd0JBQXdCLDBCQUFhOztBQUVyQyxjQUFjOztBQUVkOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQixpQkFBaUI7O0FBRWpCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBeUM7O0FBRXpDOztBQUVBLEdBQUcseUNBQXlDOztBQUU1Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsc0VBQXNF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O0FBQzFELG1CQUFtQjtBQUNuQixjQUFjO0FBQ2QscUJBQXFCO0FBQ3JCLGNBQWM7O0FBRWQsY0FBYzs7QUFFZCxZQUFZLDhCQUFpQjtBQUM3QixZQUFZLDhCQUFpQjs7QUFFN0IsY0FBYztBQUNkOztBQUVBO0FBQ0E7O0FBRUEsaUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLE9BQU8sbUJBQW1CLFFBQVE7QUFDbEQ7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDLG1CQUFtQixjQUFjIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBhdXRob3IgcWlhbyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9xaWFvXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKiBAYXV0aG9yIGVyaWNoNjY2IC8gaHR0cDovL2VyaWNoYWluZXMuY29tXG4gKi9cbi8qZ2xvYmFsIFRIUkVFLCBjb25zb2xlICovXG5cbi8vIFRoaXMgc2V0IG9mIGNvbnRyb2xzIHBlcmZvcm1zIG9yYml0aW5nLCBkb2xseWluZyAoem9vbWluZyksIGFuZCBwYW5uaW5nLiBJdCBtYWludGFpbnNcbi8vIHRoZSBcInVwXCIgZGlyZWN0aW9uIGFzICtZLCB1bmxpa2UgdGhlIFRyYWNrYmFsbENvbnRyb2xzLiBUb3VjaCBvbiB0YWJsZXQgYW5kIHBob25lcyBpc1xuLy8gc3VwcG9ydGVkLlxuLy9cbi8vICAgIE9yYml0IC0gbGVmdCBtb3VzZSAvIHRvdWNoOiBvbmUgZmluZ2VyIG1vdmVcbi8vICAgIFpvb20gLSBtaWRkbGUgbW91c2UsIG9yIG1vdXNld2hlZWwgLyB0b3VjaDogdHdvIGZpbmdlciBzcHJlYWQgb3Igc3F1aXNoXG4vLyAgICBQYW4gLSByaWdodCBtb3VzZSwgb3IgYXJyb3cga2V5cyAvIHRvdWNoOiB0aHJlZSBmaW50ZXIgc3dpcGVcbi8vXG4vLyBUaGlzIGlzIGEgZHJvcC1pbiByZXBsYWNlbWVudCBmb3IgKG1vc3QpIFRyYWNrYmFsbENvbnRyb2xzIHVzZWQgaW4gZXhhbXBsZXMuXG4vLyBUaGF0IGlzLCBpbmNsdWRlIHRoaXMganMgZmlsZSBhbmQgd2hlcmV2ZXIgeW91IHNlZTpcbi8vICAgIFx0Y29udHJvbHMgPSBuZXcgVEhSRUUuVHJhY2tiYWxsQ29udHJvbHMoIGNhbWVyYSApO1xuLy8gICAgICBjb250cm9scy50YXJnZXQueiA9IDE1MDtcbi8vIFNpbXBsZSBzdWJzdGl0dXRlIFwiT3JiaXRDb250cm9sc1wiIGFuZCB0aGUgY29udHJvbCBzaG91bGQgd29yayBhcy1pcy5cblxuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuXG5leHBvcnQgZnVuY3Rpb24gT3JiaXRDb250cm9scyggb2JqZWN0LCBkb21FbGVtZW50ICkge1xuXG5cdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXHR0aGlzLmRvbUVsZW1lbnQgPSAoIGRvbUVsZW1lbnQgIT09IHVuZGVmaW5lZCApID8gZG9tRWxlbWVudCA6IGRvY3VtZW50O1xuXG5cdC8vIEFQSVxuXG5cdC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHRoaXMgY29udHJvbFxuXHR0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXG5cdC8vIFwidGFyZ2V0XCIgc2V0cyB0aGUgbG9jYXRpb24gb2YgZm9jdXMsIHdoZXJlIHRoZSBjb250cm9sIG9yYml0cyBhcm91bmRcblx0Ly8gYW5kIHdoZXJlIGl0IHBhbnMgd2l0aCByZXNwZWN0IHRvLlxuXHR0aGlzLnRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0Ly8gY2VudGVyIGlzIG9sZCwgZGVwcmVjYXRlZDsgdXNlIFwidGFyZ2V0XCIgaW5zdGVhZFxuXHR0aGlzLmNlbnRlciA9IHRoaXMudGFyZ2V0O1xuXG5cdC8vIFRoaXMgb3B0aW9uIGFjdHVhbGx5IGVuYWJsZXMgZG9sbHlpbmcgaW4gYW5kIG91dDsgbGVmdCBhcyBcInpvb21cIiBmb3Jcblx0Ly8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0dGhpcy5ub1pvb20gPSBmYWxzZTtcblx0dGhpcy56b29tU3BlZWQgPSAxLjA7XG5cblx0Ly8gTGltaXRzIHRvIGhvdyBmYXIgeW91IGNhbiBkb2xseSBpbiBhbmQgb3V0XG5cdHRoaXMubWluRGlzdGFuY2UgPSAwO1xuXHR0aGlzLm1heERpc3RhbmNlID0gSW5maW5pdHk7XG5cblx0Ly8gU2V0IHRvIHRydWUgdG8gZGlzYWJsZSB0aGlzIGNvbnRyb2xcblx0dGhpcy5ub1JvdGF0ZSA9IGZhbHNlO1xuXHR0aGlzLnJvdGF0ZVNwZWVkID0gMS4wO1xuXG5cdC8vIFNldCB0byB0cnVlIHRvIGRpc2FibGUgdGhpcyBjb250cm9sXG5cdHRoaXMubm9QYW4gPSBmYWxzZTtcblx0dGhpcy5rZXlQYW5TcGVlZCA9IDcuMDtcdC8vIHBpeGVscyBtb3ZlZCBwZXIgYXJyb3cga2V5IHB1c2hcblxuXHQvLyBTZXQgdG8gdHJ1ZSB0byBhdXRvbWF0aWNhbGx5IHJvdGF0ZSBhcm91bmQgdGhlIHRhcmdldFxuXHR0aGlzLmF1dG9Sb3RhdGUgPSBmYWxzZTtcblx0dGhpcy5hdXRvUm90YXRlU3BlZWQgPSAyLjA7IC8vIDMwIHNlY29uZHMgcGVyIHJvdW5kIHdoZW4gZnBzIGlzIDYwXG5cblx0Ly8gSG93IGZhciB5b3UgY2FuIG9yYml0IHZlcnRpY2FsbHksIHVwcGVyIGFuZCBsb3dlciBsaW1pdHMuXG5cdC8vIFJhbmdlIGlzIDAgdG8gTWF0aC5QSSByYWRpYW5zLlxuXHR0aGlzLm1pblBvbGFyQW5nbGUgPSAwOyAvLyByYWRpYW5zXG5cdHRoaXMubWF4UG9sYXJBbmdsZSA9IE1hdGguUEk7IC8vIHJhZGlhbnNcblxuXHQvLyBTZXQgdG8gdHJ1ZSB0byBkaXNhYmxlIHVzZSBvZiB0aGUga2V5c1xuXHR0aGlzLm5vS2V5cyA9IGZhbHNlO1xuXG5cdC8vIFRoZSBmb3VyIGFycm93IGtleXNcblx0dGhpcy5rZXlzID0geyBMRUZUOiAzNywgVVA6IDM4LCBSSUdIVDogMzksIEJPVFRPTTogNDAgfTtcblxuXHQvLy8vLy8vLy8vLy9cblx0Ly8gaW50ZXJuYWxzXG5cblx0dmFyIHNjb3BlID0gdGhpcztcblxuXHR2YXIgRVBTID0gMC4wMDAwMDE7XG5cblx0dmFyIHJvdGF0ZVN0YXJ0ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0dmFyIHJvdGF0ZUVuZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdHZhciByb3RhdGVEZWx0YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cblx0dmFyIHBhblN0YXJ0ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0dmFyIHBhbkVuZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdHZhciBwYW5EZWx0YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdHZhciBwYW5PZmZzZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdHZhciBvZmZzZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdHZhciBkb2xseVN0YXJ0ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0dmFyIGRvbGx5RW5kID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0dmFyIGRvbGx5RGVsdGEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG5cdHZhciBwaGlEZWx0YSA9IDA7XG5cdHZhciB0aGV0YURlbHRhID0gMDtcblx0dmFyIHNjYWxlID0gMTtcblx0dmFyIHBhbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0dmFyIGxhc3RQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0dmFyIFNUQVRFID0geyBOT05FIDogLTEsIFJPVEFURSA6IDAsIERPTExZIDogMSwgUEFOIDogMiwgVE9VQ0hfUk9UQVRFIDogMywgVE9VQ0hfRE9MTFkgOiA0LCBUT1VDSF9QQU4gOiA1IH07XG5cblx0dmFyIHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHQvLyBmb3IgcmVzZXRcblxuXHR0aGlzLnRhcmdldDAgPSB0aGlzLnRhcmdldC5jbG9uZSgpO1xuXHR0aGlzLnBvc2l0aW9uMCA9IHRoaXMub2JqZWN0LnBvc2l0aW9uLmNsb25lKCk7XG5cblx0Ly8gZXZlbnRzXG5cblx0dmFyIGNoYW5nZUV2ZW50ID0geyB0eXBlOiAnY2hhbmdlJyB9O1xuXHR2YXIgc3RhcnRFdmVudCA9IHsgdHlwZTogJ3N0YXJ0J307XG5cdHZhciBlbmRFdmVudCA9IHsgdHlwZTogJ2VuZCd9O1xuXG5cdHRoaXMucm90YXRlTGVmdCA9IGZ1bmN0aW9uICggYW5nbGUgKSB7XG5cblx0XHRpZiAoIGFuZ2xlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGFuZ2xlID0gZ2V0QXV0b1JvdGF0aW9uQW5nbGUoKTtcblxuXHRcdH1cblxuXHRcdHRoZXRhRGVsdGEgLT0gYW5nbGU7XG5cblx0fTtcblxuXHR0aGlzLnJvdGF0ZVVwID0gZnVuY3Rpb24gKCBhbmdsZSApIHtcblxuXHRcdGlmICggYW5nbGUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0YW5nbGUgPSBnZXRBdXRvUm90YXRpb25BbmdsZSgpO1xuXG5cdFx0fVxuXG5cdFx0cGhpRGVsdGEgLT0gYW5nbGU7XG5cblx0fTtcblxuXHQvLyBwYXNzIGluIGRpc3RhbmNlIGluIHdvcmxkIHNwYWNlIHRvIG1vdmUgbGVmdFxuXHR0aGlzLnBhbkxlZnQgPSBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5vYmplY3QubWF0cml4LmVsZW1lbnRzO1xuXG5cdFx0Ly8gZ2V0IFggY29sdW1uIG9mIG1hdHJpeFxuXHRcdHBhbk9mZnNldC5zZXQoIHRlWyAwIF0sIHRlWyAxIF0sIHRlWyAyIF0gKTtcblx0XHRwYW5PZmZzZXQubXVsdGlwbHlTY2FsYXIoIC0gZGlzdGFuY2UgKTtcblx0XHRcblx0XHRwYW4uYWRkKCBwYW5PZmZzZXQgKTtcblxuXHR9O1xuXG5cdC8vIHBhc3MgaW4gZGlzdGFuY2UgaW4gd29ybGQgc3BhY2UgdG8gbW92ZSB1cFxuXHR0aGlzLnBhblVwID0gZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMub2JqZWN0Lm1hdHJpeC5lbGVtZW50cztcblxuXHRcdC8vIGdldCBZIGNvbHVtbiBvZiBtYXRyaXhcblx0XHRwYW5PZmZzZXQuc2V0KCB0ZVsgNCBdLCB0ZVsgNSBdLCB0ZVsgNiBdICk7XG5cdFx0cGFuT2Zmc2V0Lm11bHRpcGx5U2NhbGFyKCBkaXN0YW5jZSApO1xuXHRcdFxuXHRcdHBhbi5hZGQoIHBhbk9mZnNldCApO1xuXG5cdH07XG5cdFxuXHQvLyBwYXNzIGluIHgseSBvZiBjaGFuZ2UgZGVzaXJlZCBpbiBwaXhlbCBzcGFjZSxcblx0Ly8gcmlnaHQgYW5kIGRvd24gYXJlIHBvc2l0aXZlXG5cdHRoaXMucGFuID0gZnVuY3Rpb24gKCBkZWx0YVgsIGRlbHRhWSApIHtcblxuXHRcdHZhciBlbGVtZW50ID0gc2NvcGUuZG9tRWxlbWVudCA9PT0gZG9jdW1lbnQgPyBzY29wZS5kb21FbGVtZW50LmJvZHkgOiBzY29wZS5kb21FbGVtZW50O1xuXG5cdFx0aWYgKCBzY29wZS5vYmplY3QuZm92ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdC8vIHBlcnNwZWN0aXZlXG5cdFx0XHR2YXIgcG9zaXRpb24gPSBzY29wZS5vYmplY3QucG9zaXRpb247XG5cdFx0XHR2YXIgb2Zmc2V0ID0gcG9zaXRpb24uY2xvbmUoKS5zdWIoIHNjb3BlLnRhcmdldCApO1xuXHRcdFx0dmFyIHRhcmdldERpc3RhbmNlID0gb2Zmc2V0Lmxlbmd0aCgpO1xuXG5cdFx0XHQvLyBoYWxmIG9mIHRoZSBmb3YgaXMgY2VudGVyIHRvIHRvcCBvZiBzY3JlZW5cblx0XHRcdHRhcmdldERpc3RhbmNlICo9IE1hdGgudGFuKCAoIHNjb3BlLm9iamVjdC5mb3YgLyAyICkgKiBNYXRoLlBJIC8gMTgwLjAgKTtcblxuXHRcdFx0Ly8gd2UgYWN0dWFsbHkgZG9uJ3QgdXNlIHNjcmVlbldpZHRoLCBzaW5jZSBwZXJzcGVjdGl2ZSBjYW1lcmEgaXMgZml4ZWQgdG8gc2NyZWVuIGhlaWdodFxuXHRcdFx0c2NvcGUucGFuTGVmdCggMiAqIGRlbHRhWCAqIHRhcmdldERpc3RhbmNlIC8gZWxlbWVudC5jbGllbnRIZWlnaHQgKTtcblx0XHRcdHNjb3BlLnBhblVwKCAyICogZGVsdGFZICogdGFyZ2V0RGlzdGFuY2UgLyBlbGVtZW50LmNsaWVudEhlaWdodCApO1xuXG5cdFx0fSBlbHNlIGlmICggc2NvcGUub2JqZWN0LnRvcCAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgXG5cdFx0XHQvLyBvcnRob2dyYXBoaWNcblx0XHRcdHNjb3BlLnBhbkxlZnQoIGRlbHRhWCAqIChzY29wZS5vYmplY3QucmlnaHQgLSBzY29wZS5vYmplY3QubGVmdCkgLyBlbGVtZW50LmNsaWVudFdpZHRoICk7XG5cdFx0XHRzY29wZS5wYW5VcCggZGVsdGFZICogKHNjb3BlLm9iamVjdC50b3AgLSBzY29wZS5vYmplY3QuYm90dG9tKSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBjYW1lcmEgbmVpdGhlciBvcnRob2dyYXBoaWMgb3IgcGVyc3BlY3RpdmVcblx0XHRcdGNvbnNvbGUud2FybiggJ1dBUk5JTkc6IE9yYml0Q29udHJvbHMuanMgZW5jb3VudGVyZWQgYW4gdW5rbm93biBjYW1lcmEgdHlwZSAtIHBhbiBkaXNhYmxlZC4nICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHR0aGlzLmRvbGx5SW4gPSBmdW5jdGlvbiAoIGRvbGx5U2NhbGUgKSB7XG5cblx0XHRpZiAoIGRvbGx5U2NhbGUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0ZG9sbHlTY2FsZSA9IGdldFpvb21TY2FsZSgpO1xuXG5cdFx0fVxuXG5cdFx0c2NhbGUgLz0gZG9sbHlTY2FsZTtcblxuXHR9O1xuXG5cdHRoaXMuZG9sbHlPdXQgPSBmdW5jdGlvbiAoIGRvbGx5U2NhbGUgKSB7XG5cblx0XHRpZiAoIGRvbGx5U2NhbGUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0ZG9sbHlTY2FsZSA9IGdldFpvb21TY2FsZSgpO1xuXG5cdFx0fVxuXG5cdFx0c2NhbGUgKj0gZG9sbHlTY2FsZTtcblxuXHR9O1xuXG5cdHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBcbiAgICAgICAgaWYoc2NvcGUub2JqZWN0LnRvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9iamVjdC50b3AgPSAoc2NhbGUqdGhpcy5vYmplY3QudG9wKTtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0LmJvdHRvbSA9IChzY2FsZSp0aGlzLm9iamVjdC5ib3R0b20pO1xuICAgICAgICAgICAgdGhpcy5vYmplY3QubGVmdCA9IChzY2FsZSp0aGlzLm9iamVjdC5sZWZ0KTtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0LnJpZ2h0ID0gKHNjYWxlKnRoaXMub2JqZWN0LnJpZ2h0KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5vYmplY3QudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG4gICAgICAgIH1cbiAgICAgICAgICAgIFxuXG5cdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5vYmplY3QucG9zaXRpb247XG5cblx0XHRvZmZzZXQuY29weSggcG9zaXRpb24gKS5zdWIoIHRoaXMudGFyZ2V0ICk7XG4vL1xuLy9cdFx0Ly8gYW5nbGUgZnJvbSB6LWF4aXMgYXJvdW5kIHktYXhpc1xuLy9cbi8vXHRcdHZhciB0aGV0YSA9IE1hdGguYXRhbjIoIG9mZnNldC54LCBvZmZzZXQueiApO1xuLy9cbi8vXHRcdC8vIGFuZ2xlIGZyb20geS1heGlzXG4vL1xuLy9cdFx0dmFyIHBoaSA9IE1hdGguYXRhbjIoIE1hdGguc3FydCggb2Zmc2V0LnggKiBvZmZzZXQueCArIG9mZnNldC56ICogb2Zmc2V0LnogKSwgb2Zmc2V0LnkgKTtcbi8vXG4vL1x0XHRpZiAoIHRoaXMuYXV0b1JvdGF0ZSApIHtcbi8vXG4vL1x0XHRcdHRoaXMucm90YXRlTGVmdCggZ2V0QXV0b1JvdGF0aW9uQW5nbGUoKSApO1xuLy9cbi8vXHRcdH1cbi8vXG4vL1x0XHR0aGV0YSArPSB0aGV0YURlbHRhO1xuLy9cdFx0cGhpICs9IHBoaURlbHRhO1xuLy9cbi8vXHRcdC8vIHJlc3RyaWN0IHBoaSB0byBiZSBiZXR3ZWVuIGRlc2lyZWQgbGltaXRzXG4vL1x0XHRwaGkgPSBNYXRoLm1heCggdGhpcy5taW5Qb2xhckFuZ2xlLCBNYXRoLm1pbiggdGhpcy5tYXhQb2xhckFuZ2xlLCBwaGkgKSApO1xuLy9cbi8vXHRcdC8vIHJlc3RyaWN0IHBoaSB0byBiZSBiZXR3ZWUgRVBTIGFuZCBQSS1FUFNcbi8vXHRcdHBoaSA9IE1hdGgubWF4KCBFUFMsIE1hdGgubWluKCBNYXRoLlBJIC0gRVBTLCBwaGkgKSApO1xuLy9cbi8vXHRcdHZhciByYWRpdXMgPSBvZmZzZXQubGVuZ3RoKCkgKiBzY2FsZTtcbi8vXG4vL1x0XHQvLyByZXN0cmljdCByYWRpdXMgdG8gYmUgYmV0d2VlbiBkZXNpcmVkIGxpbWl0c1xuLy9cdFx0cmFkaXVzID0gTWF0aC5tYXgoIHRoaXMubWluRGlzdGFuY2UsIE1hdGgubWluKCB0aGlzLm1heERpc3RhbmNlLCByYWRpdXMgKSApO1xuLy9cdFx0XG4vL1x0XHQvLyBtb3ZlIHRhcmdldCB0byBwYW5uZWQgbG9jYXRpb25cblx0XHR0aGlzLnRhcmdldC5hZGQoIHBhbiApO1xuLy9cdFx0XG4vL1x0XHRvZmZzZXQueCA9IHJhZGl1cyAqIE1hdGguc2luKCBwaGkgKSAqIE1hdGguc2luKCB0aGV0YSApO1xuLy9cdFx0b2Zmc2V0LnkgPSByYWRpdXMgKiBNYXRoLmNvcyggcGhpICk7XG4vL1x0XHRvZmZzZXQueiA9IHJhZGl1cyAqIE1hdGguc2luKCBwaGkgKSAqIE1hdGguY29zKCB0aGV0YSApO1xuLy9cblx0XHRwb3NpdGlvbi5jb3B5KCB0aGlzLnRhcmdldCApLmFkZCggb2Zmc2V0ICk7XG5cblx0XHR0aGlzLm9iamVjdC5sb29rQXQoIHRoaXMudGFyZ2V0ICk7XG5cblxuLy9cdFx0aWYgKCBsYXN0UG9zaXRpb24uZGlzdGFuY2VUbyggdGhpcy5vYmplY3QucG9zaXRpb24gKSA+IDAgfHwgc2NhbGUgIT09IDEgKSB7XG5cblx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggY2hhbmdlRXZlbnQgKTtcblxuLy9cdFx0XHRsYXN0UG9zaXRpb24uY29weSggdGhpcy5vYmplY3QucG9zaXRpb24gKTtcblxuLy9cdFx0fVxuICAgICAgICBcbi8vICAgICAgICB0aGV0YURlbHRhID0gMDtcbi8vXHRcdHBoaURlbHRhID0gMDtcblx0XHRzY2FsZSA9IDE7XG5cdFx0cGFuLnNldCggMCwgMCwgMCApO1xuXG5cdH07XG5cblxuXHR0aGlzLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0c3RhdGUgPSBTVEFURS5OT05FO1xuXG5cdFx0dGhpcy50YXJnZXQuY29weSggdGhpcy50YXJnZXQwICk7XG5cdFx0dGhpcy5vYmplY3QucG9zaXRpb24uY29weSggdGhpcy5wb3NpdGlvbjAgKTtcblxuXHRcdHRoaXMudXBkYXRlKCk7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBnZXRBdXRvUm90YXRpb25BbmdsZSgpIHtcblxuXHRcdHJldHVybiAyICogTWF0aC5QSSAvIDYwIC8gNjAgKiBzY29wZS5hdXRvUm90YXRlU3BlZWQ7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldFpvb21TY2FsZSgpIHtcblxuXHRcdHJldHVybiBNYXRoLnBvdyggMC45NSwgc2NvcGUuem9vbVNwZWVkICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIG9uTW91c2VEb3duKCBldmVudCApIHtcblxuXHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdGlmICggZXZlbnQuYnV0dG9uID09PSAwICkge1xuXHRcdFx0aWYgKCBzY29wZS5ub1JvdGF0ZSA9PT0gdHJ1ZSApIHJldHVybjtcblxuXHRcdFx0c3RhdGUgPSBTVEFURS5ST1RBVEU7XG5cblx0XHRcdHJvdGF0ZVN0YXJ0LnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXG5cdFx0fSBlbHNlIGlmICggZXZlbnQuYnV0dG9uID09PSAxICkge1xuXHRcdFx0aWYgKCBzY29wZS5ub1pvb20gPT09IHRydWUgKSByZXR1cm47XG5cblx0XHRcdHN0YXRlID0gU1RBVEUuRE9MTFk7XG5cblx0XHRcdGRvbGx5U3RhcnQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cblx0XHR9IGVsc2UgaWYgKCBldmVudC5idXR0b24gPT09IDIgKSB7XG5cdFx0XHRpZiAoIHNjb3BlLm5vUGFuID09PSB0cnVlICkgcmV0dXJuO1xuXG5cdFx0XHRzdGF0ZSA9IFNUQVRFLlBBTjtcblxuXHRcdFx0cGFuU3RhcnQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cblx0XHR9XG5cblx0XHRzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSwgZmFsc2UgKTtcblx0XHRzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZXVwJywgb25Nb3VzZVVwLCBmYWxzZSApO1xuXHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIHN0YXJ0RXZlbnQgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gb25Nb3VzZU1vdmUoIGV2ZW50ICkge1xuXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHR2YXIgZWxlbWVudCA9IHNjb3BlLmRvbUVsZW1lbnQgPT09IGRvY3VtZW50ID8gc2NvcGUuZG9tRWxlbWVudC5ib2R5IDogc2NvcGUuZG9tRWxlbWVudDtcblxuXHRcdGlmICggc3RhdGUgPT09IFNUQVRFLlJPVEFURSApIHtcblxuXHRcdFx0aWYgKCBzY29wZS5ub1JvdGF0ZSA9PT0gdHJ1ZSApIHJldHVybjtcblxuXHRcdFx0cm90YXRlRW5kLnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXHRcdFx0cm90YXRlRGVsdGEuc3ViVmVjdG9ycyggcm90YXRlRW5kLCByb3RhdGVTdGFydCApO1xuXG5cdFx0XHQvLyByb3RhdGluZyBhY3Jvc3Mgd2hvbGUgc2NyZWVuIGdvZXMgMzYwIGRlZ3JlZXMgYXJvdW5kXG5cdFx0XHRzY29wZS5yb3RhdGVMZWZ0KCAyICogTWF0aC5QSSAqIHJvdGF0ZURlbHRhLnggLyBlbGVtZW50LmNsaWVudFdpZHRoICogc2NvcGUucm90YXRlU3BlZWQgKTtcblxuXHRcdFx0Ly8gcm90YXRpbmcgdXAgYW5kIGRvd24gYWxvbmcgd2hvbGUgc2NyZWVuIGF0dGVtcHRzIHRvIGdvIDM2MCwgYnV0IGxpbWl0ZWQgdG8gMTgwXG5cdFx0XHRzY29wZS5yb3RhdGVVcCggMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS55IC8gZWxlbWVudC5jbGllbnRIZWlnaHQgKiBzY29wZS5yb3RhdGVTcGVlZCApO1xuXG5cdFx0XHRyb3RhdGVTdGFydC5jb3B5KCByb3RhdGVFbmQgKTtcblxuXHRcdH0gZWxzZSBpZiAoIHN0YXRlID09PSBTVEFURS5ET0xMWSApIHtcblxuXHRcdFx0aWYgKCBzY29wZS5ub1pvb20gPT09IHRydWUgKSByZXR1cm47XG5cblx0XHRcdGRvbGx5RW5kLnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXHRcdFx0ZG9sbHlEZWx0YS5zdWJWZWN0b3JzKCBkb2xseUVuZCwgZG9sbHlTdGFydCApO1xuXG5cdFx0XHRpZiAoIGRvbGx5RGVsdGEueSA+IDAgKSB7XG5cblx0XHRcdFx0c2NvcGUuZG9sbHlJbigpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHNjb3BlLmRvbGx5T3V0KCk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZG9sbHlTdGFydC5jb3B5KCBkb2xseUVuZCApO1xuXG5cdFx0fSBlbHNlIGlmICggc3RhdGUgPT09IFNUQVRFLlBBTiApIHtcblxuXHRcdFx0aWYgKCBzY29wZS5ub1BhbiA9PT0gdHJ1ZSApIHJldHVybjtcblxuXHRcdFx0cGFuRW5kLnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXHRcdFx0cGFuRGVsdGEuc3ViVmVjdG9ycyggcGFuRW5kLCBwYW5TdGFydCApO1xuXHRcdFx0XG5cdFx0XHRzY29wZS5wYW4oIHBhbkRlbHRhLngsIHBhbkRlbHRhLnkgKTtcblxuXHRcdFx0cGFuU3RhcnQuY29weSggcGFuRW5kICk7XG5cblx0XHR9XG5cblx0XHRzY29wZS51cGRhdGUoKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gb25Nb3VzZVVwKCAvKiBldmVudCAqLyApIHtcblxuXHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRzY29wZS5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSwgZmFsc2UgKTtcblx0XHRzY29wZS5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZXVwJywgb25Nb3VzZVVwLCBmYWxzZSApO1xuXHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIGVuZEV2ZW50ICk7XG5cdFx0c3RhdGUgPSBTVEFURS5OT05FO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBvbk1vdXNlV2hlZWwoIGV2ZW50ICkge1xuXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSB8fCBzY29wZS5ub1pvb20gPT09IHRydWUgKSByZXR1cm47XG5cblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0dmFyIGRlbHRhID0gMDtcblxuXHRcdGlmICggZXZlbnQud2hlZWxEZWx0YSAhPT0gdW5kZWZpbmVkICkgeyAvLyBXZWJLaXQgLyBPcGVyYSAvIEV4cGxvcmVyIDlcblxuXHRcdFx0ZGVsdGEgPSBldmVudC53aGVlbERlbHRhO1xuXG5cdFx0fSBlbHNlIGlmICggZXZlbnQuZGV0YWlsICE9PSB1bmRlZmluZWQgKSB7IC8vIEZpcmVmb3hcblxuXHRcdFx0ZGVsdGEgPSAtIGV2ZW50LmRldGFpbDtcblxuXHRcdH1cblxuXHRcdGlmICggZGVsdGEgPiAwICkge1xuXG5cdFx0XHRzY29wZS5kb2xseU91dCgpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0c2NvcGUuZG9sbHlJbigpO1xuXG5cdFx0fVxuXG5cdFx0c2NvcGUudXBkYXRlKCk7XG5cdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggc3RhcnRFdmVudCApO1xuXHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIGVuZEV2ZW50ICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIG9uS2V5RG93biggZXZlbnQgKSB7XG5cblx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlIHx8IHNjb3BlLm5vS2V5cyA9PT0gdHJ1ZSB8fCBzY29wZS5ub1BhbiA9PT0gdHJ1ZSApIHJldHVybjtcblx0XHRcblx0XHRzd2l0Y2ggKCBldmVudC5rZXlDb2RlICkge1xuXG5cdFx0XHRjYXNlIHNjb3BlLmtleXMuVVA6XG5cdFx0XHRcdHNjb3BlLnBhbiggMCwgc2NvcGUua2V5UGFuU3BlZWQgKTtcblx0XHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIHNjb3BlLmtleXMuQk9UVE9NOlxuXHRcdFx0XHRzY29wZS5wYW4oIDAsIC0gc2NvcGUua2V5UGFuU3BlZWQgKTtcblx0XHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIHNjb3BlLmtleXMuTEVGVDpcblx0XHRcdFx0c2NvcGUucGFuKCBzY29wZS5rZXlQYW5TcGVlZCwgMCApO1xuXHRcdFx0XHRzY29wZS51cGRhdGUoKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2Ugc2NvcGUua2V5cy5SSUdIVDpcblx0XHRcdFx0c2NvcGUucGFuKCAtIHNjb3BlLmtleVBhblNwZWVkLCAwICk7XG5cdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gdG91Y2hzdGFydCggZXZlbnQgKSB7XG5cblx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0c3dpdGNoICggZXZlbnQudG91Y2hlcy5sZW5ndGggKSB7XG5cblx0XHRcdGNhc2UgMTpcdC8vIG9uZS1maW5nZXJlZCB0b3VjaDogcm90YXRlXG5cblx0XHRcdFx0aWYgKCBzY29wZS5ub1JvdGF0ZSA9PT0gdHJ1ZSApIHJldHVybjtcblxuXHRcdFx0XHRzdGF0ZSA9IFNUQVRFLlRPVUNIX1JPVEFURTtcblxuXHRcdFx0XHRyb3RhdGVTdGFydC5zZXQoIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCwgZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIDI6XHQvLyB0d28tZmluZ2VyZWQgdG91Y2g6IGRvbGx5XG5cblx0XHRcdFx0aWYgKCBzY29wZS5ub1pvb20gPT09IHRydWUgKSByZXR1cm47XG5cblx0XHRcdFx0c3RhdGUgPSBTVEFURS5UT1VDSF9ET0xMWTtcblxuXHRcdFx0XHR2YXIgZHggPSBldmVudC50b3VjaGVzWyAwIF0ucGFnZVggLSBldmVudC50b3VjaGVzWyAxIF0ucGFnZVg7XG5cdFx0XHRcdHZhciBkeSA9IGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSAtIGV2ZW50LnRvdWNoZXNbIDEgXS5wYWdlWTtcblx0XHRcdFx0dmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KCBkeCAqIGR4ICsgZHkgKiBkeSApO1xuXHRcdFx0XHRkb2xseVN0YXJ0LnNldCggMCwgZGlzdGFuY2UgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgMzogLy8gdGhyZWUtZmluZ2VyZWQgdG91Y2g6IHBhblxuXG5cdFx0XHRcdGlmICggc2NvcGUubm9QYW4gPT09IHRydWUgKSByZXR1cm47XG5cblx0XHRcdFx0c3RhdGUgPSBTVEFURS5UT1VDSF9QQU47XG5cblx0XHRcdFx0cGFuU3RhcnQuc2V0KCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cblx0XHR9XG5cblx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBzdGFydEV2ZW50ICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHRvdWNobW92ZSggZXZlbnQgKSB7XG5cblx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHRcdHZhciBlbGVtZW50ID0gc2NvcGUuZG9tRWxlbWVudCA9PT0gZG9jdW1lbnQgPyBzY29wZS5kb21FbGVtZW50LmJvZHkgOiBzY29wZS5kb21FbGVtZW50O1xuXG5cdFx0c3dpdGNoICggZXZlbnQudG91Y2hlcy5sZW5ndGggKSB7XG5cblx0XHRcdGNhc2UgMTogLy8gb25lLWZpbmdlcmVkIHRvdWNoOiByb3RhdGVcblxuXHRcdFx0XHRpZiAoIHNjb3BlLm5vUm90YXRlID09PSB0cnVlICkgcmV0dXJuO1xuXHRcdFx0XHRpZiAoIHN0YXRlICE9PSBTVEFURS5UT1VDSF9ST1RBVEUgKSByZXR1cm47XG5cblx0XHRcdFx0cm90YXRlRW5kLnNldCggZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VYLCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVkgKTtcblx0XHRcdFx0cm90YXRlRGVsdGEuc3ViVmVjdG9ycyggcm90YXRlRW5kLCByb3RhdGVTdGFydCApO1xuXG5cdFx0XHRcdC8vIHJvdGF0aW5nIGFjcm9zcyB3aG9sZSBzY3JlZW4gZ29lcyAzNjAgZGVncmVlcyBhcm91bmRcblx0XHRcdFx0c2NvcGUucm90YXRlTGVmdCggMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS54IC8gZWxlbWVudC5jbGllbnRXaWR0aCAqIHNjb3BlLnJvdGF0ZVNwZWVkICk7XG5cdFx0XHRcdC8vIHJvdGF0aW5nIHVwIGFuZCBkb3duIGFsb25nIHdob2xlIHNjcmVlbiBhdHRlbXB0cyB0byBnbyAzNjAsIGJ1dCBsaW1pdGVkIHRvIDE4MFxuXHRcdFx0XHRzY29wZS5yb3RhdGVVcCggMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS55IC8gZWxlbWVudC5jbGllbnRIZWlnaHQgKiBzY29wZS5yb3RhdGVTcGVlZCApO1xuXG5cdFx0XHRcdHJvdGF0ZVN0YXJ0LmNvcHkoIHJvdGF0ZUVuZCApO1xuXG5cdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAyOiAvLyB0d28tZmluZ2VyZWQgdG91Y2g6IGRvbGx5XG5cblx0XHRcdFx0aWYgKCBzY29wZS5ub1pvb20gPT09IHRydWUgKSByZXR1cm47XG5cdFx0XHRcdGlmICggc3RhdGUgIT09IFNUQVRFLlRPVUNIX0RPTExZICkgcmV0dXJuO1xuXG5cdFx0XHRcdHZhciBkeCA9IGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCAtIGV2ZW50LnRvdWNoZXNbIDEgXS5wYWdlWDtcblx0XHRcdFx0dmFyIGR5ID0gZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZIC0gZXZlbnQudG91Y2hlc1sgMSBdLnBhZ2VZO1xuXHRcdFx0XHR2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoIGR4ICogZHggKyBkeSAqIGR5ICk7XG5cblx0XHRcdFx0ZG9sbHlFbmQuc2V0KCAwLCBkaXN0YW5jZSApO1xuXHRcdFx0XHRkb2xseURlbHRhLnN1YlZlY3RvcnMoIGRvbGx5RW5kLCBkb2xseVN0YXJ0ICk7XG5cblx0XHRcdFx0aWYgKCBkb2xseURlbHRhLnkgPiAwICkge1xuXG5cdFx0XHRcdFx0c2NvcGUuZG9sbHlPdXQoKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0c2NvcGUuZG9sbHlJbigpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkb2xseVN0YXJ0LmNvcHkoIGRvbGx5RW5kICk7XG5cblx0XHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIDM6IC8vIHRocmVlLWZpbmdlcmVkIHRvdWNoOiBwYW5cblxuXHRcdFx0XHRpZiAoIHNjb3BlLm5vUGFuID09PSB0cnVlICkgcmV0dXJuO1xuXHRcdFx0XHRpZiAoIHN0YXRlICE9PSBTVEFURS5UT1VDSF9QQU4gKSByZXR1cm47XG5cblx0XHRcdFx0cGFuRW5kLnNldCggZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VYLCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVkgKTtcblx0XHRcdFx0cGFuRGVsdGEuc3ViVmVjdG9ycyggcGFuRW5kLCBwYW5TdGFydCApO1xuXHRcdFx0XHRcblx0XHRcdFx0c2NvcGUucGFuKCBwYW5EZWx0YS54LCBwYW5EZWx0YS55ICk7XG5cblx0XHRcdFx0cGFuU3RhcnQuY29weSggcGFuRW5kICk7XG5cblx0XHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gdG91Y2hlbmQoIC8qIGV2ZW50ICovICkge1xuXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIGVuZEV2ZW50ICk7XG5cdFx0c3RhdGUgPSBTVEFURS5OT05FO1xuXG5cdH1cblxuXHR0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ2NvbnRleHRtZW51JywgZnVuY3Rpb24gKCBldmVudCApIHsgZXZlbnQucHJldmVudERlZmF1bHQoKTsgfSwgZmFsc2UgKTtcblx0dGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZWRvd24nLCBvbk1vdXNlRG93biwgZmFsc2UgKTtcblx0dGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZXdoZWVsJywgb25Nb3VzZVdoZWVsLCBmYWxzZSApO1xuXHR0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ0RPTU1vdXNlU2Nyb2xsJywgb25Nb3VzZVdoZWVsLCBmYWxzZSApOyAvLyBmaXJlZm94XG5cblx0dGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICd0b3VjaHN0YXJ0JywgdG91Y2hzdGFydCwgZmFsc2UgKTtcblx0dGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICd0b3VjaGVuZCcsIHRvdWNoZW5kLCBmYWxzZSApO1xuXHR0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNobW92ZScsIHRvdWNobW92ZSwgZmFsc2UgKTtcblxuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ2tleWRvd24nLCBvbktleURvd24sIGZhbHNlICk7XG5cbn07XG5cbk9yYml0Q29udHJvbHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSApOyIsImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCB7IE9yYml0Q29udHJvbHMgfSBmcm9tICcuL09yYml0Q29udHJvbHMnO1xuXG4vLyBUaHJlZS5qcyBleHRlbnNpb24gZnVuY3Rpb25zLiBXZWJwYWNrIGRvZXNuJ3Qgc2VlbSB0byBsaWtlIGl0IGlmIHdlIG1vZGlmeSB0aGUgVEhSRUUgb2JqZWN0IGRpcmVjdGx5LlxudmFyIFRIUkVFeCA9IHsgTWF0aDoge30gfTtcbi8qKlxuICogUmV0dXJucyB0aGUgYW5nbGUgaW4gcmFkaWFucyBvZiB0aGUgdmVjdG9yIChwMSxwMikuIEluIG90aGVyIHdvcmRzLCBpbWFnaW5lXG4gKiBwdXR0aW5nIHRoZSBiYXNlIG9mIHRoZSB2ZWN0b3IgYXQgY29vcmRpbmF0ZXMgKDAsMCkgYW5kIGZpbmRpbmcgdGhlIGFuZ2xlXG4gKiBmcm9tIHZlY3RvciAoMSwwKSB0byAocDEscDIpLlxuICogQHBhcmFtICB7T2JqZWN0fSBwMSBzdGFydCBwb2ludCBvZiB0aGUgdmVjdG9yXG4gKiBAcGFyYW0gIHtPYmplY3R9IHAyIGVuZCBwb2ludCBvZiB0aGUgdmVjdG9yXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBhbmdsZVxuICovXG5USFJFRXguTWF0aC5hbmdsZTIgPSBmdW5jdGlvbihwMSwgcDIpIHtcblx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjIocDEueCwgcDEueSk7XG5cdHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IyKHAyLngsIHAyLnkpO1xuXHR2Mi5zdWIodjEpOyAvLyBzZXRzIHYyIHRvIGJlIG91ciBjaG9yZFxuXHR2Mi5ub3JtYWxpemUoKTtcblx0aWYodjIueSA8IDApIHJldHVybiAtTWF0aC5hY29zKHYyLngpO1xuXHRyZXR1cm4gTWF0aC5hY29zKHYyLngpO1xufTtcblxuXG5USFJFRXguTWF0aC5wb2xhciA9IGZ1bmN0aW9uKHBvaW50LCBkaXN0YW5jZSwgYW5nbGUpIHtcblx0dmFyIHJlc3VsdCA9IHt9O1xuXHRyZXN1bHQueCA9IHBvaW50LnggKyBkaXN0YW5jZSAqIE1hdGguY29zKGFuZ2xlKTtcblx0cmVzdWx0LnkgPSBwb2ludC55ICsgZGlzdGFuY2UgKiBNYXRoLnNpbihhbmdsZSk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgcG9pbnRzIGZvciBhIGN1cnZlIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHN0YXJ0UG9pbnQgLSB0aGUgc3RhcnRpbmcgcG9pbnQgb2YgdGhlIGN1cnZlXG4gKiBAcGFyYW0gZW5kUG9pbnQgLSB0aGUgZW5kaW5nIHBvaW50IG9mIHRoZSBjdXJ2ZVxuICogQHBhcmFtIGJ1bGdlIC0gYSB2YWx1ZSBpbmRpY2F0aW5nIGhvdyBtdWNoIHRvIGN1cnZlXG4gKiBAcGFyYW0gc2VnbWVudHMgLSBudW1iZXIgb2Ygc2VnbWVudHMgYmV0d2VlbiB0aGUgdHdvIGdpdmVuIHBvaW50c1xuICovXG5USFJFRXguQnVsZ2VHZW9tZXRyeSA9IGZ1bmN0aW9uICggc3RhcnRQb2ludCwgZW5kUG9pbnQsIGJ1bGdlLCBzZWdtZW50cyApIHtcblxuXHR2YXIgdmVydGV4LCBpLFxuXHRcdGNlbnRlciwgcDAsIHAxLCBhbmdsZSxcblx0XHRyYWRpdXMsIHN0YXJ0QW5nbGUsXG5cdFx0dGhldGFBbmdsZTtcblxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy5zdGFydFBvaW50ID0gcDAgPSBzdGFydFBvaW50ID8gbmV3IFRIUkVFLlZlY3RvcjIoc3RhcnRQb2ludC54LCBzdGFydFBvaW50LnkpIDogbmV3IFRIUkVFLlZlY3RvcjIoMCwwKTtcblx0dGhpcy5lbmRQb2ludCA9IHAxID0gZW5kUG9pbnQgPyBuZXcgVEhSRUUuVmVjdG9yMihlbmRQb2ludC54LCBlbmRQb2ludC55KSA6IG5ldyBUSFJFRS5WZWN0b3IyKDEsMCk7XG5cdHRoaXMuYnVsZ2UgPSBidWxnZSA9IGJ1bGdlIHx8IDE7XG5cblx0YW5nbGUgPSA0ICogTWF0aC5hdGFuKGJ1bGdlKTtcblx0cmFkaXVzID0gcDAuZGlzdGFuY2VUbyhwMSkgLyAyIC8gTWF0aC5zaW4oYW5nbGUvMik7XG5cdGNlbnRlciA9IFRIUkVFeC5NYXRoLnBvbGFyKHN0YXJ0UG9pbnQsIHJhZGl1cywgVEhSRUV4Lk1hdGguYW5nbGUyKHAwLHAxKSArIChNYXRoLlBJIC8gMiAtIGFuZ2xlLzIpKTtcblxuXHR0aGlzLnNlZ21lbnRzID0gc2VnbWVudHMgPSBzZWdtZW50cyB8fCBNYXRoLm1heCggTWF0aC5hYnMoTWF0aC5jZWlsKGFuZ2xlLyhNYXRoLlBJLzE4KSkpLCA2KTsgLy8gQnkgZGVmYXVsdCB3YW50IGEgc2VnbWVudCByb3VnaGx5IGV2ZXJ5IDEwIGRlZ3JlZXNcblx0c3RhcnRBbmdsZSA9IFRIUkVFeC5NYXRoLmFuZ2xlMihjZW50ZXIsIHAwKTtcblx0dGhldGFBbmdsZSA9IGFuZ2xlIC8gc2VnbWVudHM7XG5cblxuXHR0aGlzLnZlcnRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMocDAueCwgcDAueSwgMCkpO1xuXG5cdGZvcihpID0gMTsgaSA8PSBzZWdtZW50cyAtIDE7IGkrKykge1xuXG5cdFx0dmVydGV4ID0gVEhSRUV4Lk1hdGgucG9sYXIoY2VudGVyLCBNYXRoLmFicyhyYWRpdXMpLCBzdGFydEFuZ2xlICsgdGhldGFBbmdsZSAqIGkpO1xuXG5cdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKHZlcnRleC54LCB2ZXJ0ZXgueSwgMCkpO1xuXG5cdH1cblxufTtcblxuVEhSRUV4LkJ1bGdlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG4gICAgXG4vKipcbiAqIFZpZXdlciBjbGFzcyBmb3IgYSBkeGYgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSB0aGUgZHhmIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IHBhcmVudCAtIHRoZSBwYXJlbnQgZWxlbWVudCB0byB3aGljaCB3ZSBhdHRhY2ggdGhlIHJlbmRlcmluZyBjYW52YXNcbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIHdpZHRoIG9mIHRoZSByZW5kZXJpbmcgY2FudmFzIGluIHBpeGVsc1xuICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIGhlaWdodCBvZiB0aGUgcmVuZGVyaW5nIGNhbnZhcyBpbiBwaXhlbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBmb250IC0gYSBmb250IGxvYWRlZCB3aXRoIFRIUkVFLkZvbnRMb2FkZXIgXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFZpZXdlcihkYXRhLCBwYXJlbnQsIHdpZHRoLCBoZWlnaHQsIGZvbnQpIHtcblxuICAgIGNyZWF0ZUxpbmVUeXBlU2hhZGVycyhkYXRhKTtcblxuICAgIHZhciBzY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuXG4gICAgLy8gQ3JlYXRlIHNjZW5lIGZyb20gZHhmIG9iamVjdCAoZGF0YSlcbiAgICB2YXIgaSwgZW50aXR5LCBvYmosIG1pbl94LCBtaW5feSwgbWluX3osIG1heF94LCBtYXhfeSwgbWF4X3o7XG4gICAgdmFyIGRpbXMgPSB7XG4gICAgICAgIG1pbjogeyB4OiBmYWxzZSwgeTogZmFsc2UsIHo6IGZhbHNlfSxcbiAgICAgICAgbWF4OiB7IHg6IGZhbHNlLCB5OiBmYWxzZSwgejogZmFsc2V9XG4gICAgfTtcbiAgICBmb3IoaSA9IDA7IGkgPCBkYXRhLmVudGl0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVudGl0eSA9IGRhdGEuZW50aXRpZXNbaV07XG4gICAgICAgIG9iaiA9IGRyYXdFbnRpdHkoZW50aXR5LCBkYXRhKTtcblxuICAgICAgICBpZiAob2JqKSB7XG4gICAgICAgICAgICB2YXIgYmJveCA9IG5ldyBUSFJFRS5Cb3gzKCkuc2V0RnJvbU9iamVjdChvYmopO1xuICAgICAgICAgICAgaWYgKGJib3gubWluLnggJiYgKChkaW1zLm1pbi54ID09PSBmYWxzZSkgfHwgKGRpbXMubWluLnggPiBiYm94Lm1pbi54KSkpIGRpbXMubWluLnggPSBiYm94Lm1pbi54O1xuICAgICAgICAgICAgaWYgKGJib3gubWluLnkgJiYgKChkaW1zLm1pbi55ID09PSBmYWxzZSkgfHwgKGRpbXMubWluLnkgPiBiYm94Lm1pbi55KSkpIGRpbXMubWluLnkgPSBiYm94Lm1pbi55O1xuICAgICAgICAgICAgaWYgKGJib3gubWluLnogJiYgKChkaW1zLm1pbi56ID09PSBmYWxzZSkgfHwgKGRpbXMubWluLnogPiBiYm94Lm1pbi56KSkpIGRpbXMubWluLnogPSBiYm94Lm1pbi56O1xuICAgICAgICAgICAgaWYgKGJib3gubWF4LnggJiYgKChkaW1zLm1heC54ID09PSBmYWxzZSkgfHwgKGRpbXMubWF4LnggPCBiYm94Lm1heC54KSkpIGRpbXMubWF4LnggPSBiYm94Lm1heC54O1xuICAgICAgICAgICAgaWYgKGJib3gubWF4LnkgJiYgKChkaW1zLm1heC55ID09PSBmYWxzZSkgfHwgKGRpbXMubWF4LnkgPCBiYm94Lm1heC55KSkpIGRpbXMubWF4LnkgPSBiYm94Lm1heC55O1xuICAgICAgICAgICAgaWYgKGJib3gubWF4LnogJiYgKChkaW1zLm1heC56ID09PSBmYWxzZSkgfHwgKGRpbXMubWF4LnogPCBiYm94Lm1heC56KSkpIGRpbXMubWF4LnogPSBiYm94Lm1heC56O1xuICAgICAgICAgICAgc2NlbmUuYWRkKG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgb2JqID0gbnVsbDtcbiAgICB9XG5cbiAgICB3aWR0aCA9IHdpZHRoIHx8IHBhcmVudC5pbm5lcldpZHRoO1xuICAgIGhlaWdodCA9IGhlaWdodCB8fCBwYXJlbnQuaW5uZXJIZWlnaHQ7XG4gICAgdmFyIGFzcGVjdFJhdGlvID0gd2lkdGggLyBoZWlnaHQ7XG5cbiAgICB2YXIgdXBwZXJSaWdodENvcm5lciA9IHsgeDogZGltcy5tYXgueCwgeTogZGltcy5tYXgueSB9O1xuICAgIHZhciBsb3dlckxlZnRDb3JuZXIgPSB7IHg6IGRpbXMubWluLngsIHk6IGRpbXMubWluLnkgfTtcblxuICAgIC8vIEZpZ3VyZSBvdXQgdGhlIGN1cnJlbnQgdmlld3BvcnQgZXh0ZW50c1xuICAgIHZhciB2cF93aWR0aCA9IHVwcGVyUmlnaHRDb3JuZXIueCAtIGxvd2VyTGVmdENvcm5lci54O1xuICAgIHZhciB2cF9oZWlnaHQgPSB1cHBlclJpZ2h0Q29ybmVyLnkgLSBsb3dlckxlZnRDb3JuZXIueTtcbiAgICB2YXIgY2VudGVyID0gY2VudGVyIHx8IHtcbiAgICAgICAgeDogdnBfd2lkdGggLyAyICsgbG93ZXJMZWZ0Q29ybmVyLngsXG4gICAgICAgIHk6IHZwX2hlaWdodCAvIDIgKyBsb3dlckxlZnRDb3JuZXIueVxuICAgIH07XG5cbiAgICAvLyBGaXQgYWxsIG9iamVjdHMgaW50byBjdXJyZW50IFRocmVlRFhGIHZpZXdlclxuICAgIHZhciBleHRlbnRzQXNwZWN0UmF0aW8gPSBNYXRoLmFicyh2cF93aWR0aCAvIHZwX2hlaWdodCk7XG4gICAgaWYgKGFzcGVjdFJhdGlvID4gZXh0ZW50c0FzcGVjdFJhdGlvKSB7XG4gICAgICAgIHZwX3dpZHRoID0gdnBfaGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdnBfaGVpZ2h0ID0gdnBfd2lkdGggLyBhc3BlY3RSYXRpbztcbiAgICB9XG4gICAgXG4gICAgdmFyIHZpZXdQb3J0ID0ge1xuICAgICAgICBib3R0b206IC12cF9oZWlnaHQgLyAyLFxuICAgICAgICBsZWZ0OiAtdnBfd2lkdGggLyAyLFxuICAgICAgICB0b3A6IHZwX2hlaWdodCAvIDIsXG4gICAgICAgIHJpZ2h0OiB2cF93aWR0aCAvIDIsXG4gICAgICAgIGNlbnRlcjoge1xuICAgICAgICAgICAgeDogY2VudGVyLngsXG4gICAgICAgICAgICB5OiBjZW50ZXIueVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBjYW1lcmEgPSBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKHZpZXdQb3J0LmxlZnQsIHZpZXdQb3J0LnJpZ2h0LCB2aWV3UG9ydC50b3AsIHZpZXdQb3J0LmJvdHRvbSwgMSwgMTkpO1xuICAgIGNhbWVyYS5wb3NpdGlvbi56ID0gMTA7XG4gICAgY2FtZXJhLnBvc2l0aW9uLnggPSB2aWV3UG9ydC5jZW50ZXIueDtcbiAgICBjYW1lcmEucG9zaXRpb24ueSA9IHZpZXdQb3J0LmNlbnRlci55O1xuXG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKCk7XG4gICAgcmVuZGVyZXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICByZW5kZXJlci5zZXRDbGVhckNvbG9yKDB4ZmZmZmZmZiwgMSk7XG5cbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQocmVuZGVyZXIuZG9tRWxlbWVudCk7XG4gICAgcGFyZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgLy9UT0RPOiBOZWVkIHRvIG1ha2UgdGhpcyBhbiBvcHRpb24gc29tZWhvdyBzbyBvdGhlcnMgY2FuIHJvbGwgdGhlaXIgb3duIGNvbnRyb2xzLlxuICAgIHZhciBjb250cm9scyA9IG5ldyBPcmJpdENvbnRyb2xzKGNhbWVyYSwgcGFyZW50KTtcbiAgICBjb250cm9scy50YXJnZXQueCA9IGNhbWVyYS5wb3NpdGlvbi54O1xuICAgIGNvbnRyb2xzLnRhcmdldC55ID0gY2FtZXJhLnBvc2l0aW9uLnk7XG4gICAgY29udHJvbHMudGFyZ2V0LnogPSAwO1xuICAgIGNvbnRyb2xzLnpvb21TcGVlZCA9IDM7XG5cbiAgICAvL1VuY29tbWVudCB0aGlzIHRvIGRpc2FibGUgcm90YXRpb24gKGRvZXMgbm90IG1ha2UgbXVjaCBzZW5zZSB3aXRoIDJEIGRyYXdpbmdzKS5cbiAgICAvL2NvbnRyb2xzLmVuYWJsZVJvdGF0ZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbigpIHsgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpIH07XG4gICAgY29udHJvbHMuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5yZW5kZXIpO1xuICAgIHRoaXMucmVuZGVyKCk7XG4gICAgY29udHJvbHMudXBkYXRlKCk7XG5cbiAgICB0aGlzLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsV2lkdGggPSByZW5kZXJlci5kb21FbGVtZW50LndpZHRoO1xuICAgICAgICB2YXIgb3JpZ2luYWxIZWlnaHQgPSByZW5kZXJlci5kb21FbGVtZW50LmhlaWdodDtcblxuICAgICAgICB2YXIgaHNjYWxlID0gd2lkdGggLyBvcmlnaW5hbFdpZHRoO1xuICAgICAgICB2YXIgdnNjYWxlID0gaGVpZ2h0IC8gb3JpZ2luYWxIZWlnaHQ7XG5cblxuICAgICAgICBjYW1lcmEudG9wID0gKHZzY2FsZSAqIGNhbWVyYS50b3ApO1xuICAgICAgICBjYW1lcmEuYm90dG9tID0gKHZzY2FsZSAqIGNhbWVyYS5ib3R0b20pO1xuICAgICAgICBjYW1lcmEubGVmdCA9IChoc2NhbGUgKiBjYW1lcmEubGVmdCk7XG4gICAgICAgIGNhbWVyYS5yaWdodCA9IChoc2NhbGUgKiBjYW1lcmEucmlnaHQpO1xuXG4vLyAgICAgICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuICAgICAgICByZW5kZXJlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICByZW5kZXJlci5zZXRDbGVhckNvbG9yKDB4ZmZmZmZmZiwgMSk7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGRyYXdFbnRpdHkoZW50aXR5LCBkYXRhKSB7XG4gICAgICAgIHZhciBtZXNoO1xuICAgICAgICBpZihlbnRpdHkudHlwZSA9PT0gJ0NJUkNMRScgfHwgZW50aXR5LnR5cGUgPT09ICdBUkMnKSB7XG4gICAgICAgICAgICBtZXNoID0gZHJhd0FyYyhlbnRpdHksIGRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYoZW50aXR5LnR5cGUgPT09ICdMV1BPTFlMSU5FJyB8fCBlbnRpdHkudHlwZSA9PT0gJ0xJTkUnIHx8IGVudGl0eS50eXBlID09PSAnUE9MWUxJTkUnKSB7XG4gICAgICAgICAgICBtZXNoID0gZHJhd0xpbmUoZW50aXR5LCBkYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmKGVudGl0eS50eXBlID09PSAnVEVYVCcpIHtcbiAgICAgICAgICAgIG1lc2ggPSBkcmF3VGV4dChlbnRpdHksIGRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYoZW50aXR5LnR5cGUgPT09ICdTT0xJRCcpIHtcbiAgICAgICAgICAgIG1lc2ggPSBkcmF3U29saWQoZW50aXR5LCBkYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmKGVudGl0eS50eXBlID09PSAnUE9JTlQnKSB7XG4gICAgICAgICAgICBtZXNoID0gZHJhd1BvaW50KGVudGl0eSwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZihlbnRpdHkudHlwZSA9PT0gJ0lOU0VSVCcpIHtcbiAgICAgICAgICAgIG1lc2ggPSBkcmF3QmxvY2soZW50aXR5LCBkYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmKGVudGl0eS50eXBlID09PSAnU1BMSU5FJykge1xuICAgICAgICAgICAgbWVzaCA9IGRyYXdTcGxpbmUoZW50aXR5LCBkYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmKGVudGl0eS50eXBlID09PSAnTVRFWFQnKSB7XG4gICAgICAgICAgICBtZXNoID0gZHJhd010ZXh0KGVudGl0eSwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZihlbnRpdHkudHlwZSA9PT0gJ0VMTElQU0UnKSB7XG4gICAgICAgICAgICBtZXNoID0gZHJhd0VsbGlwc2UoZW50aXR5LCBkYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmKGVudGl0eS50eXBlID09PSAnRElNRU5TSU9OJykge1xuICAgICAgICAgICAgdmFyIGRpbVR5cGVFbnVtID0gZW50aXR5LmRpbWVuc2lvblR5cGUgJiA3O1xuICAgICAgICAgICAgaWYoZGltVHlwZUVudW0gPT09IDApIHtcbiAgICAgICAgICAgICAgICBtZXNoID0gZHJhd0RpbWVuc2lvbihlbnRpdHksIGRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlVuc3VwcG9ydGVkIERpbWVuc2lvbiB0eXBlOiBcIiArIGRpbVR5cGVFbnVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVW5zdXBwb3J0ZWQgRW50aXR5IFR5cGU6IFwiICsgZW50aXR5LnR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyYXdFbGxpcHNlKGVudGl0eSwgZGF0YSkge1xuICAgICAgICB2YXIgY29sb3IgPSBnZXRDb2xvcihlbnRpdHksIGRhdGEpO1xuXG4gICAgICAgIHZhciB4cmFkID0gTWF0aC5zcXJ0KE1hdGgucG93KGVudGl0eS5tYWpvckF4aXNFbmRQb2ludC54LDIpICsgTWF0aC5wb3coZW50aXR5Lm1ham9yQXhpc0VuZFBvaW50LnksMikpO1xuICAgICAgICB2YXIgeXJhZCA9IHhyYWQqZW50aXR5LmF4aXNSYXRpbztcbiAgICAgICAgdmFyIHJvdGF0aW9uID0gTWF0aC5hdGFuMihlbnRpdHkubWFqb3JBeGlzRW5kUG9pbnQueSwgZW50aXR5Lm1ham9yQXhpc0VuZFBvaW50LngpO1xuXG4gICAgICAgIHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5FbGxpcHNlQ3VydmUoXG4gICAgICAgICAgICBlbnRpdHkuY2VudGVyLngsICBlbnRpdHkuY2VudGVyLnksXG4gICAgICAgICAgICB4cmFkLCB5cmFkLFxuICAgICAgICAgICAgZW50aXR5LnN0YXJ0QW5nbGUsIGVudGl0eS5lbmRBbmdsZSxcbiAgICAgICAgICAgIGZhbHNlLCAvLyBBbHdheXMgY291bnRlcmNsb2Nrd2lzZVxuICAgICAgICAgICAgcm90YXRpb25cbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgcG9pbnRzID0gY3VydmUuZ2V0UG9pbnRzKCA1MCApO1xuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKS5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKTtcbiAgICAgICAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7ICBsaW5ld2lkdGg6IDEsIGNvbG9yIDogY29sb3IgfSApO1xuXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgZmluYWwgb2JqZWN0IHRvIGFkZCB0byB0aGUgc2NlbmVcbiAgICAgICAgdmFyIGVsbGlwc2UgPSBuZXcgVEhSRUUuTGluZSggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG4gICAgICAgIHJldHVybiBlbGxpcHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyYXdNdGV4dChlbnRpdHksIGRhdGEpIHtcbiAgICAgICAgdmFyIGNvbG9yID0gZ2V0Q29sb3IoZW50aXR5LCBkYXRhKTtcblxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuVGV4dEdlb21ldHJ5KCBlbnRpdHkudGV4dCwge1xuICAgICAgICAgICAgZm9udDogZm9udCxcbiAgICAgICAgICAgIHNpemU6IGVudGl0eS5oZWlnaHQgKiAoNC81KSxcbiAgICAgICAgICAgIGhlaWdodDogMVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7Y29sb3I6IGNvbG9yfSApO1xuICAgICAgICB2YXIgdGV4dCA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuICAgICAgICAvLyBNZWFzdXJlIHdoYXQgd2UgcmVuZGVyZWQuXG4gICAgICAgIHZhciBtZWFzdXJlID0gbmV3IFRIUkVFLkJveDMoKTtcbiAgICAgICAgbWVhc3VyZS5zZXRGcm9tT2JqZWN0KCB0ZXh0ICk7XG5cbiAgICAgICAgdmFyIHRleHRXaWR0aCAgPSBtZWFzdXJlLm1heC54IC0gbWVhc3VyZS5taW4ueDtcblxuICAgICAgICAvLyBJZiB0aGUgdGV4dCBlbmRzIHVwIGJlaW5nIHdpZGVyIHRoYW4gdGhlIGJveCwgaXQncyBzdXBwb3NlZFxuICAgICAgICAvLyB0byBiZSBtdWx0aWxpbmUuIERvaW5nIHRoYXQgaW4gdGhyZWVKUyBpcyBvdmVya2lsbC5cbiAgICAgICAgaWYgKHRleHRXaWR0aCA+IGVudGl0eS53aWR0aCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJDYW4ndCByZW5kZXIgdGhpcyBtdWx0aXBsaW5lIE1URVhUIGVudGl0eSwgc29ycnkuXCIsIGVudGl0eSk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdGV4dC5wb3NpdGlvbi56ID0gMDtcbiAgICAgICAgc3dpdGNoIChlbnRpdHkuYXR0YWNobWVudFBvaW50KSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgLy8gVG9wIExlZnRcbiAgICAgICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnggPSBlbnRpdHkucG9zaXRpb24ueDtcbiAgICAgICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnkgPSBlbnRpdHkucG9zaXRpb24ueSAtIGVudGl0eS5oZWlnaHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAvLyBUb3AgQ2VudGVyXG4gICAgICAgICAgICAgICAgdGV4dC5wb3NpdGlvbi54ID0gZW50aXR5LnBvc2l0aW9uLnggLSB0ZXh0V2lkdGgvMjtcbiAgICAgICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnkgPSBlbnRpdHkucG9zaXRpb24ueSAtIGVudGl0eS5oZWlnaHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAvLyBUb3AgUmlnaHRcbiAgICAgICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnggPSBlbnRpdHkucG9zaXRpb24ueCAtIHRleHRXaWR0aDtcbiAgICAgICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnkgPSBlbnRpdHkucG9zaXRpb24ueSAtIGVudGl0eS5oZWlnaHQ7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIC8vIE1pZGRsZSBMZWZ0XG4gICAgICAgICAgICAgICAgdGV4dC5wb3NpdGlvbi54ID0gZW50aXR5LnBvc2l0aW9uLng7XG4gICAgICAgICAgICAgICAgdGV4dC5wb3NpdGlvbi55ID0gZW50aXR5LnBvc2l0aW9uLnkgLSBlbnRpdHkuaGVpZ2h0LzI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAvLyBNaWRkbGUgQ2VudGVyXG4gICAgICAgICAgICAgICAgdGV4dC5wb3NpdGlvbi54ID0gZW50aXR5LnBvc2l0aW9uLnggLSB0ZXh0V2lkdGgvMjtcbiAgICAgICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnkgPSBlbnRpdHkucG9zaXRpb24ueSAtIGVudGl0eS5oZWlnaHQvMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIC8vIE1pZGRsZSBSaWdodFxuICAgICAgICAgICAgICAgIHRleHQucG9zaXRpb24ueCA9IGVudGl0eS5wb3NpdGlvbi54IC0gdGV4dFdpZHRoO1xuICAgICAgICAgICAgICAgIHRleHQucG9zaXRpb24ueSA9IGVudGl0eS5wb3NpdGlvbi55IC0gZW50aXR5LmhlaWdodC8yO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAvLyBCb3R0b20gTGVmdFxuICAgICAgICAgICAgICAgIHRleHQucG9zaXRpb24ueCA9IGVudGl0eS5wb3NpdGlvbi54O1xuICAgICAgICAgICAgICAgIHRleHQucG9zaXRpb24ueSA9IGVudGl0eS5wb3NpdGlvbi55O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgLy8gQm90dG9tIENlbnRlclxuICAgICAgICAgICAgICAgIHRleHQucG9zaXRpb24ueCA9IGVudGl0eS5wb3NpdGlvbi54IC0gdGV4dFdpZHRoLzI7XG4gICAgICAgICAgICAgICAgdGV4dC5wb3NpdGlvbi55ID0gZW50aXR5LnBvc2l0aW9uLnk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAvLyBCb3R0b20gUmlnaHRcbiAgICAgICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnggPSBlbnRpdHkucG9zaXRpb24ueCAtIHRleHRXaWR0aDtcbiAgICAgICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnkgPSBlbnRpdHkucG9zaXRpb24ueTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhd1NwbGluZShlbnRpdHksIGRhdGEpIHtcbiAgICAgICAgdmFyIGNvbG9yID0gZ2V0Q29sb3IoZW50aXR5LCBkYXRhKTtcblxuICAgICAgICB2YXIgcG9pbnRzID0gZW50aXR5LmNvbnRyb2xQb2ludHMubWFwKGZ1bmN0aW9uKHZlYykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKHZlYy54LCB2ZWMueSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBpbnRlcnBvbGF0ZWRQb2ludHMgPSBbXTtcbiAgICAgICAgdmFyIGN1cnZlO1xuICAgICAgICBpZiAoZW50aXR5LmRlZ3JlZU9mU3BsaW5lQ3VydmUgPT09IDIgfHwgZW50aXR5LmRlZ3JlZU9mU3BsaW5lQ3VydmUgPT09IDMpIHtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgKyAyIDwgcG9pbnRzLmxlbmd0aDsgaSA9IGkgKyAyKSB7XG4gICAgICAgIGlmIChlbnRpdHkuZGVncmVlT2ZTcGxpbmVDdXJ2ZSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VydmUgPSBuZXcgVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdLCBwb2ludHNbaSArIDJdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnZlID0gbmV3IFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlMyhwb2ludHNbaV0sIHBvaW50c1tpICsgMV0sIHBvaW50c1tpICsgMl0pO1xuICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkUG9pbnRzLnB1c2guYXBwbHkoaW50ZXJwb2xhdGVkUG9pbnRzLCBjdXJ2ZS5nZXRQb2ludHMoNTApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnZlID0gbmV3IFRIUkVFLlNwbGluZUN1cnZlKHBvaW50cyk7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWRQb2ludHMgPSBjdXJ2ZS5nZXRQb2ludHMoIDEwMCApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCkuc2V0RnJvbVBvaW50cyggaW50ZXJwb2xhdGVkUG9pbnRzICk7XG4gICAgICAgIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBsaW5ld2lkdGg6IDEsIGNvbG9yIDogY29sb3IgfSApO1xuICAgICAgICB2YXIgc3BsaW5lT2JqZWN0ID0gbmV3IFRIUkVFLkxpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG4gICAgICAgIHJldHVybiBzcGxpbmVPYmplY3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhd0xpbmUoZW50aXR5LCBkYXRhKSB7XG4gICAgICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpLFxuICAgICAgICAgICAgY29sb3IgPSBnZXRDb2xvcihlbnRpdHksIGRhdGEpLFxuICAgICAgICAgICAgbWF0ZXJpYWwsIGxpbmVUeXBlLCB2ZXJ0ZXgsIHN0YXJ0UG9pbnQsIGVuZFBvaW50LCBidWxnZUdlb21ldHJ5LFxuICAgICAgICAgICAgYnVsZ2UsIGksIGxpbmU7XG5cbiAgICAgICAgLy8gY3JlYXRlIGdlb21ldHJ5XG4gICAgICAgIGZvcihpID0gMDsgaSA8IGVudGl0eS52ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICBpZihlbnRpdHkudmVydGljZXNbaV0uYnVsZ2UpIHtcbiAgICAgICAgICAgICAgICBidWxnZSA9IGVudGl0eS52ZXJ0aWNlc1tpXS5idWxnZTtcbiAgICAgICAgICAgICAgICBzdGFydFBvaW50ID0gZW50aXR5LnZlcnRpY2VzW2ldO1xuICAgICAgICAgICAgICAgIGVuZFBvaW50ID0gaSArIDEgPCBlbnRpdHkudmVydGljZXMubGVuZ3RoID8gZW50aXR5LnZlcnRpY2VzW2kgKyAxXSA6IGdlb21ldHJ5LnZlcnRpY2VzWzBdO1xuXG4gICAgICAgICAgICAgICAgYnVsZ2VHZW9tZXRyeSA9IG5ldyBUSFJFRXguQnVsZ2VHZW9tZXRyeShzdGFydFBvaW50LCBlbmRQb2ludCwgYnVsZ2UpO1xuXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaC5hcHBseShnZW9tZXRyeS52ZXJ0aWNlcywgYnVsZ2VHZW9tZXRyeS52ZXJ0aWNlcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZlcnRleCA9IGVudGl0eS52ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKHZlcnRleC54LCB2ZXJ0ZXgueSwgMCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgaWYoZW50aXR5LnNoYXBlKSBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKGdlb21ldHJ5LnZlcnRpY2VzWzBdKTtcblxuXG4gICAgICAgIC8vIHNldCBtYXRlcmlhbFxuICAgICAgICBpZihlbnRpdHkubGluZVR5cGUpIHtcbiAgICAgICAgICAgIGxpbmVUeXBlID0gZGF0YS50YWJsZXMubGluZVR5cGUubGluZVR5cGVzW2VudGl0eS5saW5lVHlwZV07XG4gICAgICAgIH1cblxuICAgICAgICBpZihsaW5lVHlwZSAmJiBsaW5lVHlwZS5wYXR0ZXJuICYmIGxpbmVUeXBlLnBhdHRlcm4ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwoeyBjb2xvcjogY29sb3IsIGdhcFNpemU6IDQsIGRhc2hTaXplOiA0fSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCh7IGxpbmV3aWR0aDogMSwgY29sb3I6IGNvbG9yIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYobGluZVR5cGUgJiYgbGluZVR5cGUucGF0dGVybiAmJiBsaW5lVHlwZS5wYXR0ZXJuLmxlbmd0aCAhPT0gMCkge1xuXG4gICAgICAgIC8vICAgICAgICAgICBnZW9tZXRyeS5jb21wdXRlTGluZURpc3RhbmNlcygpO1xuXG4gICAgICAgIC8vICAgICAgICAgICAvLyBVZ2x5IGhhY2sgdG8gYWRkIGRpZmZ1c2UgdG8gdGhpcy4gTWF5YmUgY29weSB0aGUgdW5pZm9ybXMgb2JqZWN0IHNvIHdlXG4gICAgICAgIC8vICAgICAgICAgICAvLyBkb24ndCBhZGQgZGlmZnVzZSB0byBhIG1hdGVyaWFsLlxuICAgICAgICAvLyAgICAgICAgICAgbGluZVR5cGUubWF0ZXJpYWwudW5pZm9ybXMuZGlmZnVzZSA9IHsgdHlwZTogJ2MnLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKGNvbG9yKSB9O1xuXG4gICAgICAgIC8vIFx0bWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgICAvLyBcdFx0dW5pZm9ybXM6IGxpbmVUeXBlLm1hdGVyaWFsLnVuaWZvcm1zLFxuICAgICAgICAvLyBcdFx0dmVydGV4U2hhZGVyOiBsaW5lVHlwZS5tYXRlcmlhbC52ZXJ0ZXhTaGFkZXIsXG4gICAgICAgIC8vIFx0XHRmcmFnbWVudFNoYWRlcjogbGluZVR5cGUubWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXJcbiAgICAgICAgLy8gXHR9KTtcbiAgICAgICAgLy8gfWVsc2Uge1xuICAgICAgICAvLyBcdG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKHsgbGluZXdpZHRoOiAxLCBjb2xvcjogY29sb3IgfSk7XG4gICAgICAgIC8vIH1cblxuICAgICAgICBsaW5lID0gbmV3IFRIUkVFLkxpbmUoZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGRyYXdBcmMoZW50aXR5LCBkYXRhKSB7XG4gICAgICAgIHZhciBzdGFydEFuZ2xlLCBlbmRBbmdsZTtcbiAgICAgICAgaWYgKGVudGl0eS50eXBlID09PSAnQ0lSQ0xFJykge1xuICAgICAgICAgICAgc3RhcnRBbmdsZSA9IGVudGl0eS5zdGFydEFuZ2xlIHx8IDA7XG4gICAgICAgICAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyAyICogTWF0aC5QSTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBlbnRpdHkuc3RhcnRBbmdsZTtcbiAgICAgICAgICAgIGVuZEFuZ2xlID0gZW50aXR5LmVuZEFuZ2xlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN1cnZlID0gbmV3IFRIUkVFLkFyY0N1cnZlKFxuICAgICAgICAgICAgMCwgMCxcbiAgICAgICAgICAgIGVudGl0eS5yYWRpdXMsXG4gICAgICAgICAgICBzdGFydEFuZ2xlLFxuICAgICAgICAgICAgZW5kQW5nbGUpO1xuXG4gICAgICAgIHZhciBwb2ludHMgPSBjdXJ2ZS5nZXRQb2ludHMoIDMyICk7XG4gICAgICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpLnNldEZyb21Qb2ludHMoIHBvaW50cyApO1xuXG4gICAgICAgIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiBnZXRDb2xvcihlbnRpdHksIGRhdGEpIH0pO1xuXG4gICAgICAgIHZhciBhcmMgPSBuZXcgVEhSRUUuTGluZShnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgICBhcmMucG9zaXRpb24ueCA9IGVudGl0eS5jZW50ZXIueDtcbiAgICAgICAgYXJjLnBvc2l0aW9uLnkgPSBlbnRpdHkuY2VudGVyLnk7XG4gICAgICAgIGFyYy5wb3NpdGlvbi56ID0gZW50aXR5LmNlbnRlci56O1xuXG4gICAgICAgIHJldHVybiBhcmM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhd1NvbGlkKGVudGl0eSwgZGF0YSkge1xuICAgICAgICB2YXIgbWF0ZXJpYWwsIG1lc2gsIHZlcnRzLFxuICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblxuICAgICAgICB2ZXJ0cyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuICAgICAgICB2ZXJ0cy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKGVudGl0eS5wb2ludHNbMF0ueCwgZW50aXR5LnBvaW50c1swXS55LCBlbnRpdHkucG9pbnRzWzBdLnopKTtcbiAgICAgICAgdmVydHMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyhlbnRpdHkucG9pbnRzWzFdLngsIGVudGl0eS5wb2ludHNbMV0ueSwgZW50aXR5LnBvaW50c1sxXS56KSk7XG4gICAgICAgIHZlcnRzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMoZW50aXR5LnBvaW50c1syXS54LCBlbnRpdHkucG9pbnRzWzJdLnksIGVudGl0eS5wb2ludHNbMl0ueikpO1xuICAgICAgICB2ZXJ0cy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKGVudGl0eS5wb2ludHNbM10ueCwgZW50aXR5LnBvaW50c1szXS55LCBlbnRpdHkucG9pbnRzWzNdLnopKTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgd2hpY2ggZGlyZWN0aW9uIHRoZSBwb2ludHMgYXJlIGZhY2luZyAoY2xvY2t3aXNlIG9yIGNvdW50ZXItY2xvY2t3aXNlKVxuICAgICAgICB2YXIgdmVjdG9yMSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHZhciB2ZWN0b3IyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgdmVjdG9yMS5zdWJWZWN0b3JzKHZlcnRzWzFdLCB2ZXJ0c1swXSk7XG4gICAgICAgIHZlY3RvcjIuc3ViVmVjdG9ycyh2ZXJ0c1syXSwgdmVydHNbMF0pO1xuICAgICAgICB2ZWN0b3IxLmNyb3NzKHZlY3RvcjIpO1xuXG4gICAgICAgIC8vIElmIHogPCAwIHRoZW4gd2UgbXVzdCBkcmF3IHRoZXNlIGluIHJldmVyc2Ugb3JkZXJcbiAgICAgICAgaWYodmVjdG9yMS56IDwgMCkge1xuICAgICAgICAgICAgZ2VvbWV0cnkuZmFjZXMucHVzaChuZXcgVEhSRUUuRmFjZTMoMiwgMSwgMCkpO1xuICAgICAgICAgICAgZ2VvbWV0cnkuZmFjZXMucHVzaChuZXcgVEhSRUUuRmFjZTMoMiwgMywgMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2VvbWV0cnkuZmFjZXMucHVzaChuZXcgVEhSRUUuRmFjZTMoMCwgMSwgMikpO1xuICAgICAgICAgICAgZ2VvbWV0cnkuZmFjZXMucHVzaChuZXcgVEhSRUUuRmFjZTMoMSwgMywgMikpO1xuICAgICAgICB9XG5cblxuICAgICAgICBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiBnZXRDb2xvcihlbnRpdHksIGRhdGEpIH0pO1xuXG4gICAgICAgIHJldHVybiBuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgICBcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkcmF3VGV4dChlbnRpdHksIGRhdGEpIHtcbiAgICAgICAgdmFyIGdlb21ldHJ5LCBtYXRlcmlhbCwgdGV4dDtcblxuICAgICAgICBpZighZm9udClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ1RleHQgaXMgbm90IHN1cHBvcnRlZCB3aXRob3V0IGEgVGhyZWUuanMgZm9udCBsb2FkZWQgd2l0aCBUSFJFRS5Gb250TG9hZGVyISBMb2FkIGEgZm9udCBvZiB5b3VyIGNob2ljZSBhbmQgcGFzcyB0aGlzIGludG8gdGhlIGNvbnN0cnVjdG9yLiBTZWUgdGhlIHNhbXBsZSBmb3IgdGhpcyByZXBvc2l0b3J5IG9yIFRocmVlLmpzIGV4YW1wbGVzIGF0IGh0dHA6Ly90aHJlZWpzLm9yZy9leGFtcGxlcy8/cT10ZXh0I3dlYmdsX2dlb21ldHJ5X3RleHQgZm9yIG1vcmUgZGV0YWlscy4nKTtcbiAgICAgICAgXG4gICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRleHRHZW9tZXRyeShlbnRpdHkudGV4dCwgeyBmb250OiBmb250LCBoZWlnaHQ6IDAsIHNpemU6IGVudGl0eS50ZXh0SGVpZ2h0IHx8IDEyIH0pO1xuXG4gICAgICAgIGlmIChlbnRpdHkucm90YXRpb24pIHtcbiAgICAgICAgICAgIHZhciB6Um90YXRpb24gPSBlbnRpdHkucm90YXRpb24gKiBNYXRoLlBJIC8gMTgwO1xuICAgICAgICAgICAgZ2VvbWV0cnkucm90YXRlWih6Um90YXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogZ2V0Q29sb3IoZW50aXR5LCBkYXRhKSB9KTtcblxuICAgICAgICB0ZXh0ID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgdGV4dC5wb3NpdGlvbi54ID0gZW50aXR5LnN0YXJ0UG9pbnQueDtcbiAgICAgICAgdGV4dC5wb3NpdGlvbi55ID0gZW50aXR5LnN0YXJ0UG9pbnQueTtcbiAgICAgICAgdGV4dC5wb3NpdGlvbi56ID0gZW50aXR5LnN0YXJ0UG9pbnQuejtcblxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkcmF3UG9pbnQoZW50aXR5LCBkYXRhKSB7XG4gICAgICAgIHZhciBnZW9tZXRyeSwgbWF0ZXJpYWwsIHBvaW50O1xuXG4gICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG5cbiAgICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyhlbnRpdHkucG9zaXRpb24ueCwgZW50aXR5LnBvc2l0aW9uLnksIGVudGl0eS5wb3NpdGlvbi56KSk7XG5cbiAgICAgICAgLy8gVE9ETzogY291bGQgYmUgbW9yZSBlZmZpY2llbnQuIFBvaW50Q2xvdWQgcGVyIGxheWVyP1xuXG4gICAgICAgIHZhciBudW1Qb2ludHMgPSAxO1xuXG4gICAgICAgIHZhciBjb2xvciA9IGdldENvbG9yKGVudGl0eSwgZGF0YSk7XG4gICAgICAgIHZhciBjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KCBudW1Qb2ludHMqMyApO1xuICAgICAgICBjb2xvcnNbMF0gPSBjb2xvci5yO1xuICAgICAgICBjb2xvcnNbMV0gPSBjb2xvci5nO1xuICAgICAgICBjb2xvcnNbMl0gPSBjb2xvci5iO1xuXG4gICAgICAgIGdlb21ldHJ5LmNvbG9ycyA9IGNvbG9ycztcbiAgICAgICAgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cbiAgICAgICAgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuUG9pbnRzTWF0ZXJpYWwoIHsgc2l6ZTogMC4wNSwgdmVydGV4Q29sb3JzOiBUSFJFRS5WZXJ0ZXhDb2xvcnMgfSApO1xuICAgICAgICBwb2ludCA9IG5ldyBUSFJFRS5Qb2ludHMoZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgc2NlbmUuYWRkKHBvaW50KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkcmF3RGltZW5zaW9uKGVudGl0eSwgZGF0YSkge1xuICAgICAgICB2YXIgYmxvY2sgPSBkYXRhLmJsb2Nrc1tlbnRpdHkuYmxvY2tdO1xuXG4gICAgICAgIGlmICghYmxvY2sgfHwgIWJsb2NrLmVudGl0aWVzKSByZXR1cm4gbnVsbDtcblxuICAgICAgICB2YXIgZ3JvdXAgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcbiAgICAgICAgLy8gaWYoZW50aXR5LmFuY2hvclBvaW50KSB7XG4gICAgICAgIC8vICAgICBncm91cC5wb3NpdGlvbi54ID0gZW50aXR5LmFuY2hvclBvaW50Lng7XG4gICAgICAgIC8vICAgICBncm91cC5wb3NpdGlvbi55ID0gZW50aXR5LmFuY2hvclBvaW50Lnk7XG4gICAgICAgIC8vICAgICBncm91cC5wb3NpdGlvbi56ID0gZW50aXR5LmFuY2hvclBvaW50Lno7XG4gICAgICAgIC8vIH1cblxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmxvY2suZW50aXRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZEVudGl0eSA9IGRyYXdFbnRpdHkoYmxvY2suZW50aXRpZXNbaV0sIGRhdGEsIGdyb3VwKTtcbiAgICAgICAgICAgIGlmKGNoaWxkRW50aXR5KSBncm91cC5hZGQoY2hpbGRFbnRpdHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyYXdCbG9jayhlbnRpdHksIGRhdGEpIHtcbiAgICAgICAgdmFyIGJsb2NrID0gZGF0YS5ibG9ja3NbZW50aXR5Lm5hbWVdO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFibG9jay5lbnRpdGllcykgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgdmFyIGdyb3VwID0gbmV3IFRIUkVFLk9iamVjdDNEKClcbiAgICAgICAgXG4gICAgICAgIGlmKGVudGl0eS54U2NhbGUpIGdyb3VwLnNjYWxlLnggPSBlbnRpdHkueFNjYWxlO1xuICAgICAgICBpZihlbnRpdHkueVNjYWxlKSBncm91cC5zY2FsZS55ID0gZW50aXR5LnlTY2FsZTtcblxuICAgICAgICBpZihlbnRpdHkucm90YXRpb24pIHtcbiAgICAgICAgICAgIGdyb3VwLnJvdGF0aW9uLnogPSBlbnRpdHkucm90YXRpb24gKiBNYXRoLlBJIC8gMTgwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoZW50aXR5LnBvc2l0aW9uKSB7XG4gICAgICAgICAgICBncm91cC5wb3NpdGlvbi54ID0gZW50aXR5LnBvc2l0aW9uLng7XG4gICAgICAgICAgICBncm91cC5wb3NpdGlvbi55ID0gZW50aXR5LnBvc2l0aW9uLnk7XG4gICAgICAgICAgICBncm91cC5wb3NpdGlvbi56ID0gZW50aXR5LnBvc2l0aW9uLno7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBibG9jay5lbnRpdGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkRW50aXR5ID0gZHJhd0VudGl0eShibG9jay5lbnRpdGllc1tpXSwgZGF0YSwgZ3JvdXApO1xuICAgICAgICAgICAgaWYoY2hpbGRFbnRpdHkpIGdyb3VwLmFkZChjaGlsZEVudGl0eSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q29sb3IoZW50aXR5LCBkYXRhKSB7XG4gICAgICAgIHZhciBjb2xvciA9IDB4MDAwMDAwOyAvL2RlZmF1bHRcbiAgICAgICAgaWYoZW50aXR5LmNvbG9yKSBjb2xvciA9IGVudGl0eS5jb2xvcjtcbiAgICAgICAgZWxzZSBpZihkYXRhLnRhYmxlcyAmJiBkYXRhLnRhYmxlcy5sYXllciAmJiBkYXRhLnRhYmxlcy5sYXllci5sYXllcnNbZW50aXR5LmxheWVyXSlcbiAgICAgICAgICAgIGNvbG9yID0gZGF0YS50YWJsZXMubGF5ZXIubGF5ZXJzW2VudGl0eS5sYXllcl0uY29sb3I7XG4gICAgICAgICAgICBcbiAgICAgICAgaWYoY29sb3IgPT0gbnVsbCB8fCBjb2xvciA9PT0gMHhmZmZmZmYpIHtcbiAgICAgICAgICAgIGNvbG9yID0gMHgwMDAwMDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxpbmVUeXBlU2hhZGVycyhkYXRhKSB7XG4gICAgICAgIHZhciBsdHlwZSwgdHlwZTtcbiAgICAgICAgaWYoIWRhdGEudGFibGVzIHx8ICFkYXRhLnRhYmxlcy5saW5lVHlwZSkgcmV0dXJuO1xuICAgICAgICB2YXIgbHR5cGVzID0gZGF0YS50YWJsZXMubGluZVR5cGUubGluZVR5cGVzO1xuXG4gICAgICAgIGZvcih0eXBlIGluIGx0eXBlcykge1xuICAgICAgICAgICAgbHR5cGUgPSBsdHlwZXNbdHlwZV07XG4gICAgICAgICAgICBpZighbHR5cGUucGF0dGVybikgY29udGludWU7XG4gICAgICAgICAgICBsdHlwZS5tYXRlcmlhbCA9IGNyZWF0ZURhc2hlZExpbmVTaGFkZXIobHR5cGUucGF0dGVybik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEYXNoZWRMaW5lU2hhZGVyKHBhdHRlcm4pIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBkYXNoZWRMaW5lU2hhZGVyID0ge30sXG4gICAgICAgICAgICB0b3RhbExlbmd0aCA9IDAuMDtcblxuICAgICAgICBmb3IoaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b3RhbExlbmd0aCArPSBNYXRoLmFicyhwYXR0ZXJuW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhc2hlZExpbmVTaGFkZXIudW5pZm9ybXMgPSBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKFtcblxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbICdjb21tb24nIF0sXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgJ2ZvZycgXSxcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICdwYXR0ZXJuJzogeyB0eXBlOiAnZnYxJywgdmFsdWU6IHBhdHRlcm4gfSxcbiAgICAgICAgICAgICAgICAncGF0dGVybkxlbmd0aCc6IHsgdHlwZTogJ2YnLCB2YWx1ZTogdG90YWxMZW5ndGggfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIF0pO1xuXG4gICAgICAgIGRhc2hlZExpbmVTaGFkZXIudmVydGV4U2hhZGVyID0gW1xuICAgICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBsaW5lRGlzdGFuY2U7JyxcblxuICAgICAgICAgICAgJ3ZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTsnLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgJ2NvbG9yX3BhcnNfdmVydGV4JyBdLFxuXG4gICAgICAgICAgICAndm9pZCBtYWluKCkgeycsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyAnY29sb3JfdmVydGV4JyBdLFxuXG4gICAgICAgICAgICAndkxpbmVEaXN0YW5jZSA9IGxpbmVEaXN0YW5jZTsnLFxuXG4gICAgICAgICAgICAnZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApOycsXG5cbiAgICAgICAgICAgICd9J1xuICAgICAgICBdLmpvaW4oJ1xcbicpO1xuXG4gICAgICAgIGRhc2hlZExpbmVTaGFkZXIuZnJhZ21lbnRTaGFkZXIgPSBbXG4gICAgICAgICAgICAndW5pZm9ybSB2ZWMzIGRpZmZ1c2U7JyxcbiAgICAgICAgICAgICd1bmlmb3JtIGZsb2F0IG9wYWNpdHk7JyxcblxuICAgICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgcGF0dGVyblsnICsgcGF0dGVybi5sZW5ndGggKyAnXTsnLFxuICAgICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgcGF0dGVybkxlbmd0aDsnLFxuXG4gICAgICAgICAgICAndmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlOycsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyAnY29sb3JfcGFyc19mcmFnbWVudCcgXSxcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyAnZm9nX3BhcnNfZnJhZ21lbnQnIF0sXG5cbiAgICAgICAgICAgICd2b2lkIG1haW4oKSB7JyxcblxuICAgICAgICAgICAgJ2Zsb2F0IHBvcyA9IG1vZCh2TGluZURpc3RhbmNlLCBwYXR0ZXJuTGVuZ3RoKTsnLFxuXG4gICAgICAgICAgICAnZm9yICggaW50IGkgPSAwOyBpIDwgJyArIHBhdHRlcm4ubGVuZ3RoICsgJzsgaSsrICkgeycsXG4gICAgICAgICAgICAncG9zID0gcG9zIC0gYWJzKHBhdHRlcm5baV0pOycsXG4gICAgICAgICAgICAnaWYoIHBvcyA8IDAuMCApIHsnLFxuICAgICAgICAgICAgJ2lmKCBwYXR0ZXJuW2ldID4gMC4wICkgeycsXG4gICAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gdmVjNCgxLjAsIDAuMCwgMC4wLCBvcGFjaXR5ICk7JyxcbiAgICAgICAgICAgICdicmVhazsnLFxuICAgICAgICAgICAgJ30nLFxuICAgICAgICAgICAgJ2Rpc2NhcmQ7JyxcbiAgICAgICAgICAgICd9JyxcblxuICAgICAgICAgICAgJ30nLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgJ2NvbG9yX2ZyYWdtZW50JyBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbICdmb2dfZnJhZ21lbnQnIF0sXG5cbiAgICAgICAgICAgICd9J1xuICAgICAgICBdLmpvaW4oJ1xcbicpO1xuXG4gICAgICAgIHJldHVybiBkYXNoZWRMaW5lU2hhZGVyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmRFeHRlbnRzKHNjZW5lKSB7IFxuICAgICAgICBmb3IodmFyIGNoaWxkIG9mIHNjZW5lLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICB2YXIgbWluWCwgbWF4WCwgbWluWSwgbWF4WTtcbiAgICAgICAgICAgIGlmKGNoaWxkLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgbWluWCA9IE1hdGgubWluKGNoaWxkLnBvc2l0aW9uLngsIG1pblgpO1xuICAgICAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihjaGlsZC5wb3NpdGlvbi55LCBtaW5ZKTtcbiAgICAgICAgICAgICAgICBtYXhYID0gTWF0aC5tYXgoY2hpbGQucG9zaXRpb24ueCwgbWF4WCk7XG4gICAgICAgICAgICAgICAgbWF4WSA9IE1hdGgubWF4KGNoaWxkLnBvc2l0aW9uLnksIG1heFkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgbWluOiB7IHg6IG1pblgsIHk6IG1pblkgfSwgbWF4OiB7IHg6IG1heFgsIHk6IG1heFkgfX07XG4gICAgfVxuXG59XG5cblxuLy8gU2hvdy9IaWRlIGhlbHBlcnMgZnJvbSBodHRwczovL3BsYWluanMuY29tL2phdmFzY3JpcHQvZWZmZWN0cy9oaWRlLW9yLXNob3ctYW4tZWxlbWVudC00Mi9cbi8vIGdldCB0aGUgZGVmYXVsdCBkaXNwbGF5IHN0eWxlIG9mIGFuIGVsZW1lbnRcbmZ1bmN0aW9uIGRlZmF1bHREaXNwbGF5KHRhZykge1xuICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdmcmFtZWJvcmRlcicsIDApO1xuICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgMCk7XG4gICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgMCk7XG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGlmcmFtZSk7XG5cbiAgICB2YXIgZG9jID0gKGlmcmFtZS5jb250ZW50V2luZG93IHx8IGlmcmFtZS5jb250ZW50RG9jdW1lbnQpLmRvY3VtZW50O1xuXG4gICAgLy8gSUUgc3VwcG9ydFxuICAgIGRvYy53cml0ZSgpO1xuICAgIGRvYy5jbG9zZSgpO1xuXG4gICAgdmFyIHRlc3RFbCA9IGRvYy5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgZG9jLmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCh0ZXN0RWwpO1xuICAgIHZhciBkaXNwbGF5ID0gKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlID8gZ2V0Q29tcHV0ZWRTdHlsZSh0ZXN0RWwsIG51bGwpIDogdGVzdEVsLmN1cnJlbnRTdHlsZSkuZGlzcGxheVxuICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgcmV0dXJuIGRpc3BsYXk7XG59XG5cbi8vIGFjdHVhbCBzaG93L2hpZGUgZnVuY3Rpb24gdXNlZCBieSBzaG93KCkgYW5kIGhpZGUoKSBiZWxvd1xuZnVuY3Rpb24gc2hvd0hpZGUoZWwsIHNob3cpIHtcbiAgICB2YXIgdmFsdWUgPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtb2xkZGlzcGxheScpLFxuICAgIGRpc3BsYXkgPSBlbC5zdHlsZS5kaXNwbGF5LFxuICAgIGNvbXB1dGVkRGlzcGxheSA9ICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSA/IGdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpIDogZWwuY3VycmVudFN0eWxlKS5kaXNwbGF5O1xuXG4gICAgaWYgKHNob3cpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSAmJiBkaXNwbGF5ID09PSAnbm9uZScpIGVsLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgICAgaWYgKGVsLnN0eWxlLmRpc3BsYXkgPT09ICcnICYmIChjb21wdXRlZERpc3BsYXkgPT09ICdub25lJykpIHZhbHVlID0gdmFsdWUgfHwgZGVmYXVsdERpc3BsYXkoZWwubm9kZU5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChkaXNwbGF5ICYmIGRpc3BsYXkgIT09ICdub25lJyB8fCAhKGNvbXB1dGVkRGlzcGxheSA9PSAnbm9uZScpKVxuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdkYXRhLW9sZGRpc3BsYXknLCAoY29tcHV0ZWREaXNwbGF5ID09ICdub25lJykgPyBkaXNwbGF5IDogY29tcHV0ZWREaXNwbGF5KTtcbiAgICB9XG4gICAgaWYgKCFzaG93IHx8IGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyB8fCBlbC5zdHlsZS5kaXNwbGF5ID09PSAnJylcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHNob3cgPyB2YWx1ZSB8fCAnJyA6ICdub25lJztcbn1cblxuLy8gaGVscGVyIGZ1bmN0aW9uc1xuZnVuY3Rpb24gc2hvdyhlbCkgeyBzaG93SGlkZShlbCwgdHJ1ZSk7IH1cbmZ1bmN0aW9uIGhpZGUoZWwpIHsgc2hvd0hpZGUoZWwpOyB9XG5cblxuXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n')}])});